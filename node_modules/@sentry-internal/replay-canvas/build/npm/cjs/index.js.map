{"version":3,"file":"index.js","sources":["../../../../../node_modules/@sentry-internal/rrweb/es/rrweb/packages/rrweb-snapshot/es/rrweb-snapshot.js","../../../../../node_modules/@sentry-internal/rrweb/es/rrweb/packages/rrweb/src/utils.js","../../../../../node_modules/@sentry-internal/rrweb/es/rrweb/packages/types/dist/rrweb-types.js","../../../../../node_modules/@sentry-internal/rrweb/es/rrweb/packages/rrweb/src/record/error-handler.js","../../../../../node_modules/@sentry-internal/rrweb/es/rrweb/ext/base64-arraybuffer/dist/base64-arraybuffer.es5.js","../../../../../node_modules/@sentry-internal/rrweb/es/rrweb/packages/rrweb/src/record/observers/canvas/serialize-args.js","../../../../../node_modules/@sentry-internal/rrweb/es/rrweb/packages/rrweb/src/record/observers/canvas/2d.js","../../../../../node_modules/@sentry-internal/rrweb/es/rrweb/packages/rrweb/src/record/observers/canvas/canvas.js","../../../../../node_modules/@sentry-internal/rrweb/es/rrweb/packages/rrweb/src/record/observers/canvas/webgl.js","../../../../../node_modules/@sentry-internal/rrweb/es/rrweb/packages/rrweb-worker/es/rrweb-worker/image-bitmap-data-url-worker.js","../../../../../node_modules/@sentry-internal/rrweb/es/rrweb/packages/rrweb-worker/es/rrweb-worker/index.js","../../../../../node_modules/@sentry-internal/rrweb/es/rrweb/packages/rrweb/src/record/observers/canvas/canvas-manager.js","../../../src/canvas.ts"],"sourcesContent":["var NodeType;\r\n(function (NodeType) {\r\n    NodeType[NodeType[\"Document\"] = 0] = \"Document\";\r\n    NodeType[NodeType[\"DocumentType\"] = 1] = \"DocumentType\";\r\n    NodeType[NodeType[\"Element\"] = 2] = \"Element\";\r\n    NodeType[NodeType[\"Text\"] = 3] = \"Text\";\r\n    NodeType[NodeType[\"CDATA\"] = 4] = \"CDATA\";\r\n    NodeType[NodeType[\"Comment\"] = 5] = \"Comment\";\r\n})(NodeType || (NodeType = {}));\n\nfunction isElement(n) {\r\n    return n.nodeType === n.ELEMENT_NODE;\r\n}\r\nfunction isShadowRoot(n) {\r\n    const host = n?.host;\r\n    return Boolean(host?.shadowRoot === n);\r\n}\r\nfunction isNativeShadowDom(shadowRoot) {\r\n    return Object.prototype.toString.call(shadowRoot) === '[object ShadowRoot]';\r\n}\r\nfunction fixBrowserCompatibilityIssuesInCSS(cssText) {\r\n    if (cssText.includes(' background-clip: text;') &&\r\n        !cssText.includes(' -webkit-background-clip: text;')) {\r\n        cssText = cssText.replace(/\\sbackground-clip:\\s*text;/g, ' -webkit-background-clip: text; background-clip: text;');\r\n    }\r\n    return cssText;\r\n}\r\nfunction escapeImportStatement(rule) {\r\n    const { cssText } = rule;\r\n    if (cssText.split('\"').length < 3)\r\n        return cssText;\r\n    const statement = ['@import', `url(${JSON.stringify(rule.href)})`];\r\n    if (rule.layerName === '') {\r\n        statement.push(`layer`);\r\n    }\r\n    else if (rule.layerName) {\r\n        statement.push(`layer(${rule.layerName})`);\r\n    }\r\n    if (rule.supportsText) {\r\n        statement.push(`supports(${rule.supportsText})`);\r\n    }\r\n    if (rule.media.length) {\r\n        statement.push(rule.media.mediaText);\r\n    }\r\n    return statement.join(' ') + ';';\r\n}\r\nfunction stringifyStylesheet(s) {\r\n    try {\r\n        const rules = s.rules || s.cssRules;\r\n        return rules\r\n            ? fixBrowserCompatibilityIssuesInCSS(Array.from(rules, stringifyRule).join(''))\r\n            : null;\r\n    }\r\n    catch (error) {\r\n        return null;\r\n    }\r\n}\r\nfunction fixAllCssProperty(rule) {\r\n    let styles = '';\r\n    for (let i = 0; i < rule.style.length; i++) {\r\n        const styleDeclaration = rule.style;\r\n        const attribute = styleDeclaration[i];\r\n        const isImportant = styleDeclaration.getPropertyPriority(attribute);\r\n        styles += `${attribute}:${styleDeclaration.getPropertyValue(attribute)}${isImportant ? ` !important` : ''};`;\r\n    }\r\n    return `${rule.selectorText} { ${styles} }`;\r\n}\r\nfunction stringifyRule(rule) {\r\n    let importStringified;\r\n    if (isCSSImportRule(rule)) {\r\n        try {\r\n            importStringified =\r\n                stringifyStylesheet(rule.styleSheet) ||\r\n                    escapeImportStatement(rule);\r\n        }\r\n        catch (error) {\r\n        }\r\n    }\r\n    else if (isCSSStyleRule(rule)) {\r\n        let cssText = rule.cssText;\r\n        const needsSafariColonFix = rule.selectorText.includes(':');\r\n        const needsAllFix = typeof rule.style['all'] === 'string' && rule.style['all'];\r\n        if (needsAllFix) {\r\n            cssText = fixAllCssProperty(rule);\r\n        }\r\n        if (needsSafariColonFix) {\r\n            cssText = fixSafariColons(cssText);\r\n        }\r\n        if (needsSafariColonFix || needsAllFix) {\r\n            return cssText;\r\n        }\r\n    }\r\n    return importStringified || rule.cssText;\r\n}\r\nfunction fixSafariColons(cssStringified) {\r\n    const regex = /(\\[(?:[\\w-]+)[^\\\\])(:(?:[\\w-]+)\\])/gm;\r\n    return cssStringified.replace(regex, '$1\\\\$2');\r\n}\r\nfunction isCSSImportRule(rule) {\r\n    return 'styleSheet' in rule;\r\n}\r\nfunction isCSSStyleRule(rule) {\r\n    return 'selectorText' in rule;\r\n}\r\nclass Mirror {\r\n    constructor() {\r\n        this.idNodeMap = new Map();\r\n        this.nodeMetaMap = new WeakMap();\r\n    }\r\n    getId(n) {\r\n        if (!n)\r\n            return -1;\r\n        const id = this.getMeta(n)?.id;\r\n        return id ?? -1;\r\n    }\r\n    getNode(id) {\r\n        return this.idNodeMap.get(id) || null;\r\n    }\r\n    getIds() {\r\n        return Array.from(this.idNodeMap.keys());\r\n    }\r\n    getMeta(n) {\r\n        return this.nodeMetaMap.get(n) || null;\r\n    }\r\n    removeNodeFromMap(n) {\r\n        const id = this.getId(n);\r\n        this.idNodeMap.delete(id);\r\n        if (n.childNodes) {\r\n            n.childNodes.forEach((childNode) => this.removeNodeFromMap(childNode));\r\n        }\r\n    }\r\n    has(id) {\r\n        return this.idNodeMap.has(id);\r\n    }\r\n    hasNode(node) {\r\n        return this.nodeMetaMap.has(node);\r\n    }\r\n    add(n, meta) {\r\n        const id = meta.id;\r\n        this.idNodeMap.set(id, n);\r\n        this.nodeMetaMap.set(n, meta);\r\n    }\r\n    replace(id, n) {\r\n        const oldNode = this.getNode(id);\r\n        if (oldNode) {\r\n            const meta = this.nodeMetaMap.get(oldNode);\r\n            if (meta)\r\n                this.nodeMetaMap.set(n, meta);\r\n        }\r\n        this.idNodeMap.set(id, n);\r\n    }\r\n    reset() {\r\n        this.idNodeMap = new Map();\r\n        this.nodeMetaMap = new WeakMap();\r\n    }\r\n}\r\nfunction createMirror() {\r\n    return new Mirror();\r\n}\r\nfunction shouldMaskInput({ maskInputOptions, tagName, type, }) {\r\n    if (tagName === 'OPTION') {\r\n        tagName = 'SELECT';\r\n    }\r\n    return Boolean(maskInputOptions[tagName.toLowerCase()] ||\r\n        (type && maskInputOptions[type]) ||\r\n        type === 'password' ||\r\n        (tagName === 'INPUT' && !type && maskInputOptions['text']));\r\n}\r\nfunction maskInputValue({ isMasked, element, value, maskInputFn, }) {\r\n    let text = value || '';\r\n    if (!isMasked) {\r\n        return text;\r\n    }\r\n    if (maskInputFn) {\r\n        text = maskInputFn(text, element);\r\n    }\r\n    return '*'.repeat(text.length);\r\n}\r\nfunction toLowerCase(str) {\r\n    return str.toLowerCase();\r\n}\r\nfunction toUpperCase(str) {\r\n    return str.toUpperCase();\r\n}\r\nconst ORIGINAL_ATTRIBUTE_NAME = '__rrweb_original__';\r\nfunction is2DCanvasBlank(canvas) {\r\n    const ctx = canvas.getContext('2d');\r\n    if (!ctx)\r\n        return true;\r\n    const chunkSize = 50;\r\n    for (let x = 0; x < canvas.width; x += chunkSize) {\r\n        for (let y = 0; y < canvas.height; y += chunkSize) {\r\n            const getImageData = ctx.getImageData;\r\n            const originalGetImageData = ORIGINAL_ATTRIBUTE_NAME in getImageData\r\n                ? getImageData[ORIGINAL_ATTRIBUTE_NAME]\r\n                : getImageData;\r\n            const pixelBuffer = new Uint32Array(originalGetImageData.call(ctx, x, y, Math.min(chunkSize, canvas.width - x), Math.min(chunkSize, canvas.height - y)).data.buffer);\r\n            if (pixelBuffer.some((pixel) => pixel !== 0))\r\n                return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\nfunction isNodeMetaEqual(a, b) {\r\n    if (!a || !b || a.type !== b.type)\r\n        return false;\r\n    if (a.type === NodeType.Document)\r\n        return a.compatMode === b.compatMode;\r\n    else if (a.type === NodeType.DocumentType)\r\n        return (a.name === b.name &&\r\n            a.publicId === b.publicId &&\r\n            a.systemId === b.systemId);\r\n    else if (a.type === NodeType.Comment ||\r\n        a.type === NodeType.Text ||\r\n        a.type === NodeType.CDATA)\r\n        return a.textContent === b.textContent;\r\n    else if (a.type === NodeType.Element)\r\n        return (a.tagName === b.tagName &&\r\n            JSON.stringify(a.attributes) ===\r\n                JSON.stringify(b.attributes) &&\r\n            a.isSVG === b.isSVG &&\r\n            a.needBlock === b.needBlock);\r\n    return false;\r\n}\r\nfunction getInputType(element) {\r\n    const type = element.type;\r\n    return element.hasAttribute('data-rr-is-password')\r\n        ? 'password'\r\n        : type\r\n            ?\r\n                toLowerCase(type)\r\n            : null;\r\n}\r\nfunction getInputValue(el, tagName, type) {\r\n    if (tagName === 'INPUT' && (type === 'radio' || type === 'checkbox')) {\r\n        return el.getAttribute('value') || '';\r\n    }\r\n    return el.value;\r\n}\r\nfunction extractFileExtension(path, baseURL) {\r\n    let url;\r\n    try {\r\n        url = new URL(path, baseURL ?? window.location.href);\r\n    }\r\n    catch (err) {\r\n        return null;\r\n    }\r\n    const regex = /\\.([0-9a-z]+)(?:$)/i;\r\n    const match = url.pathname.match(regex);\r\n    return match?.[1] ?? null;\r\n}\r\nconst cachedImplementations = {};\r\nfunction getImplementation(name) {\r\n    const cached = cachedImplementations[name];\r\n    if (cached) {\r\n        return cached;\r\n    }\r\n    const document = window.document;\r\n    let impl = window[name];\r\n    if (document && typeof document.createElement === 'function') {\r\n        try {\r\n            const sandbox = document.createElement('iframe');\r\n            sandbox.hidden = true;\r\n            document.head.appendChild(sandbox);\r\n            const contentWindow = sandbox.contentWindow;\r\n            if (contentWindow && contentWindow[name]) {\r\n                impl =\r\n                    contentWindow[name];\r\n            }\r\n            document.head.removeChild(sandbox);\r\n        }\r\n        catch (e) {\r\n        }\r\n    }\r\n    return (cachedImplementations[name] = impl.bind(window));\r\n}\r\nfunction setTimeout(...rest) {\r\n    return getImplementation('setTimeout')(...rest);\r\n}\r\nfunction clearTimeout(...rest) {\r\n    return getImplementation('clearTimeout')(...rest);\r\n}\r\nfunction getIframeContentDocument(iframe) {\r\n    try {\r\n        return iframe.contentDocument;\r\n    }\r\n    catch (e) {\r\n    }\r\n}\n\nlet _id = 1;\r\nconst tagNameRegex = new RegExp('[^a-z0-9-_:]');\r\nconst IGNORED_NODE = -2;\r\nfunction genId() {\r\n    return _id++;\r\n}\r\nfunction getValidTagName(element) {\r\n    if (element instanceof HTMLFormElement) {\r\n        return 'form';\r\n    }\r\n    const processedTagName = toLowerCase(element.tagName);\r\n    if (tagNameRegex.test(processedTagName)) {\r\n        return 'div';\r\n    }\r\n    return processedTagName;\r\n}\r\nfunction extractOrigin(url) {\r\n    let origin = '';\r\n    if (url.indexOf('//') > -1) {\r\n        origin = url.split('/').slice(0, 3).join('/');\r\n    }\r\n    else {\r\n        origin = url.split('/')[0];\r\n    }\r\n    origin = origin.split('?')[0];\r\n    return origin;\r\n}\r\nlet canvasService;\r\nlet canvasCtx;\r\nconst URL_IN_CSS_REF = /url\\((?:(')([^']*)'|(\")(.*?)\"|([^)]*))\\)/gm;\r\nconst URL_PROTOCOL_MATCH = /^(?:[a-z+]+:)?\\/\\//i;\r\nconst URL_WWW_MATCH = /^www\\..*/i;\r\nconst DATA_URI = /^(data:)([^,]*),(.*)/i;\r\nfunction absoluteToStylesheet(cssText, href) {\r\n    return (cssText || '').replace(URL_IN_CSS_REF, (origin, quote1, path1, quote2, path2, path3) => {\r\n        const filePath = path1 || path2 || path3;\r\n        const maybeQuote = quote1 || quote2 || '';\r\n        if (!filePath) {\r\n            return origin;\r\n        }\r\n        if (URL_PROTOCOL_MATCH.test(filePath) || URL_WWW_MATCH.test(filePath)) {\r\n            return `url(${maybeQuote}${filePath}${maybeQuote})`;\r\n        }\r\n        if (DATA_URI.test(filePath)) {\r\n            return `url(${maybeQuote}${filePath}${maybeQuote})`;\r\n        }\r\n        if (filePath[0] === '/') {\r\n            return `url(${maybeQuote}${extractOrigin(href) + filePath}${maybeQuote})`;\r\n        }\r\n        const stack = href.split('/');\r\n        const parts = filePath.split('/');\r\n        stack.pop();\r\n        for (const part of parts) {\r\n            if (part === '.') {\r\n                continue;\r\n            }\r\n            else if (part === '..') {\r\n                stack.pop();\r\n            }\r\n            else {\r\n                stack.push(part);\r\n            }\r\n        }\r\n        return `url(${maybeQuote}${stack.join('/')}${maybeQuote})`;\r\n    });\r\n}\r\nconst SRCSET_NOT_SPACES = /^[^ \\t\\n\\r\\u000c]+/;\r\nconst SRCSET_COMMAS_OR_SPACES = /^[, \\t\\n\\r\\u000c]+/;\r\nfunction getAbsoluteSrcsetString(doc, attributeValue) {\r\n    if (attributeValue.trim() === '') {\r\n        return attributeValue;\r\n    }\r\n    let pos = 0;\r\n    function collectCharacters(regEx) {\r\n        let chars;\r\n        const match = regEx.exec(attributeValue.substring(pos));\r\n        if (match) {\r\n            chars = match[0];\r\n            pos += chars.length;\r\n            return chars;\r\n        }\r\n        return '';\r\n    }\r\n    const output = [];\r\n    while (true) {\r\n        collectCharacters(SRCSET_COMMAS_OR_SPACES);\r\n        if (pos >= attributeValue.length) {\r\n            break;\r\n        }\r\n        let url = collectCharacters(SRCSET_NOT_SPACES);\r\n        if (url.slice(-1) === ',') {\r\n            url = absoluteToDoc(doc, url.substring(0, url.length - 1));\r\n            output.push(url);\r\n        }\r\n        else {\r\n            let descriptorsStr = '';\r\n            url = absoluteToDoc(doc, url);\r\n            let inParens = false;\r\n            while (true) {\r\n                const c = attributeValue.charAt(pos);\r\n                if (c === '') {\r\n                    output.push((url + descriptorsStr).trim());\r\n                    break;\r\n                }\r\n                else if (!inParens) {\r\n                    if (c === ',') {\r\n                        pos += 1;\r\n                        output.push((url + descriptorsStr).trim());\r\n                        break;\r\n                    }\r\n                    else if (c === '(') {\r\n                        inParens = true;\r\n                    }\r\n                }\r\n                else {\r\n                    if (c === ')') {\r\n                        inParens = false;\r\n                    }\r\n                }\r\n                descriptorsStr += c;\r\n                pos += 1;\r\n            }\r\n        }\r\n    }\r\n    return output.join(', ');\r\n}\r\nconst cachedDocument = new WeakMap();\r\nfunction absoluteToDoc(doc, attributeValue) {\r\n    if (!attributeValue || attributeValue.trim() === '') {\r\n        return attributeValue;\r\n    }\r\n    return getHref(doc, attributeValue);\r\n}\r\nfunction isSVGElement(el) {\r\n    return Boolean(el.tagName === 'svg' || el.ownerSVGElement);\r\n}\r\nfunction getHref(doc, customHref) {\r\n    let a = cachedDocument.get(doc);\r\n    if (!a) {\r\n        a = doc.createElement('a');\r\n        cachedDocument.set(doc, a);\r\n    }\r\n    if (!customHref) {\r\n        customHref = '';\r\n    }\r\n    else if (customHref.startsWith('blob:') || customHref.startsWith('data:')) {\r\n        return customHref;\r\n    }\r\n    a.setAttribute('href', customHref);\r\n    return a.href;\r\n}\r\nfunction transformAttribute(doc, tagName, name, value, element, maskAttributeFn) {\r\n    if (!value) {\r\n        return value;\r\n    }\r\n    if (name === 'src' ||\r\n        (name === 'href' && !(tagName === 'use' && value[0] === '#'))) {\r\n        return absoluteToDoc(doc, value);\r\n    }\r\n    else if (name === 'xlink:href' && value[0] !== '#') {\r\n        return absoluteToDoc(doc, value);\r\n    }\r\n    else if (name === 'background' &&\r\n        (tagName === 'table' || tagName === 'td' || tagName === 'th')) {\r\n        return absoluteToDoc(doc, value);\r\n    }\r\n    else if (name === 'srcset') {\r\n        return getAbsoluteSrcsetString(doc, value);\r\n    }\r\n    else if (name === 'style') {\r\n        return absoluteToStylesheet(value, getHref(doc));\r\n    }\r\n    else if (tagName === 'object' && name === 'data') {\r\n        return absoluteToDoc(doc, value);\r\n    }\r\n    if (typeof maskAttributeFn === 'function') {\r\n        return maskAttributeFn(name, value, element);\r\n    }\r\n    return value;\r\n}\r\nfunction ignoreAttribute(tagName, name, _value) {\r\n    return (tagName === 'video' || tagName === 'audio') && name === 'autoplay';\r\n}\r\nfunction _isBlockedElement(element, blockClass, blockSelector, unblockSelector) {\r\n    try {\r\n        if (unblockSelector && element.matches(unblockSelector)) {\r\n            return false;\r\n        }\r\n        if (typeof blockClass === 'string') {\r\n            if (element.classList.contains(blockClass)) {\r\n                return true;\r\n            }\r\n        }\r\n        else {\r\n            for (let eIndex = element.classList.length; eIndex--;) {\r\n                const className = element.classList[eIndex];\r\n                if (blockClass.test(className)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        if (blockSelector) {\r\n            return element.matches(blockSelector);\r\n        }\r\n    }\r\n    catch (e) {\r\n    }\r\n    return false;\r\n}\r\nfunction elementClassMatchesRegex(el, regex) {\r\n    for (let eIndex = el.classList.length; eIndex--;) {\r\n        const className = el.classList[eIndex];\r\n        if (regex.test(className)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\nfunction distanceToMatch(node, matchPredicate, limit = Infinity, distance = 0) {\r\n    if (!node)\r\n        return -1;\r\n    if (node.nodeType !== node.ELEMENT_NODE)\r\n        return -1;\r\n    if (distance > limit)\r\n        return -1;\r\n    if (matchPredicate(node))\r\n        return distance;\r\n    return distanceToMatch(node.parentNode, matchPredicate, limit, distance + 1);\r\n}\r\nfunction createMatchPredicate(className, selector) {\r\n    return (node) => {\r\n        const el = node;\r\n        if (el === null)\r\n            return false;\r\n        try {\r\n            if (className) {\r\n                if (typeof className === 'string') {\r\n                    if (el.matches(`.${className}`))\r\n                        return true;\r\n                }\r\n                else if (elementClassMatchesRegex(el, className)) {\r\n                    return true;\r\n                }\r\n            }\r\n            if (selector && el.matches(selector))\r\n                return true;\r\n            return false;\r\n        }\r\n        catch {\r\n            return false;\r\n        }\r\n    };\r\n}\r\nfunction needMaskingText(node, maskTextClass, maskTextSelector, unmaskTextClass, unmaskTextSelector, maskAllText) {\r\n    try {\r\n        const el = node.nodeType === node.ELEMENT_NODE\r\n            ? node\r\n            : node.parentElement;\r\n        if (el === null)\r\n            return false;\r\n        if (el.tagName === 'INPUT') {\r\n            const autocomplete = el.getAttribute('autocomplete');\r\n            const disallowedAutocompleteValues = [\r\n                'current-password',\r\n                'new-password',\r\n                'cc-number',\r\n                'cc-exp',\r\n                'cc-exp-month',\r\n                'cc-exp-year',\r\n                'cc-csc',\r\n            ];\r\n            if (disallowedAutocompleteValues.includes(autocomplete)) {\r\n                return true;\r\n            }\r\n        }\r\n        let maskDistance = -1;\r\n        let unmaskDistance = -1;\r\n        if (maskAllText) {\r\n            unmaskDistance = distanceToMatch(el, createMatchPredicate(unmaskTextClass, unmaskTextSelector));\r\n            if (unmaskDistance < 0) {\r\n                return true;\r\n            }\r\n            maskDistance = distanceToMatch(el, createMatchPredicate(maskTextClass, maskTextSelector), unmaskDistance >= 0 ? unmaskDistance : Infinity);\r\n        }\r\n        else {\r\n            maskDistance = distanceToMatch(el, createMatchPredicate(maskTextClass, maskTextSelector));\r\n            if (maskDistance < 0) {\r\n                return false;\r\n            }\r\n            unmaskDistance = distanceToMatch(el, createMatchPredicate(unmaskTextClass, unmaskTextSelector), maskDistance >= 0 ? maskDistance : Infinity);\r\n        }\r\n        return maskDistance >= 0\r\n            ? unmaskDistance >= 0\r\n                ? maskDistance <= unmaskDistance\r\n                : true\r\n            : unmaskDistance >= 0\r\n                ? false\r\n                : !!maskAllText;\r\n    }\r\n    catch (e) {\r\n    }\r\n    return !!maskAllText;\r\n}\r\nfunction onceIframeLoaded(iframeEl, listener, iframeLoadTimeout) {\r\n    const win = iframeEl.contentWindow;\r\n    if (!win) {\r\n        return;\r\n    }\r\n    let fired = false;\r\n    let readyState;\r\n    try {\r\n        readyState = win.document.readyState;\r\n    }\r\n    catch (error) {\r\n        return;\r\n    }\r\n    if (readyState !== 'complete') {\r\n        const timer = setTimeout(() => {\r\n            if (!fired) {\r\n                listener();\r\n                fired = true;\r\n            }\r\n        }, iframeLoadTimeout);\r\n        iframeEl.addEventListener('load', () => {\r\n            clearTimeout(timer);\r\n            fired = true;\r\n            listener();\r\n        });\r\n        return;\r\n    }\r\n    const blankUrl = 'about:blank';\r\n    if (win.location.href !== blankUrl ||\r\n        iframeEl.src === blankUrl ||\r\n        iframeEl.src === '') {\r\n        setTimeout(listener, 0);\r\n        return iframeEl.addEventListener('load', listener);\r\n    }\r\n    iframeEl.addEventListener('load', listener);\r\n}\r\nfunction onceStylesheetLoaded(link, listener, styleSheetLoadTimeout) {\r\n    let fired = false;\r\n    let styleSheetLoaded;\r\n    try {\r\n        styleSheetLoaded = link.sheet;\r\n    }\r\n    catch (error) {\r\n        return;\r\n    }\r\n    if (styleSheetLoaded)\r\n        return;\r\n    const timer = setTimeout(() => {\r\n        if (!fired) {\r\n            listener();\r\n            fired = true;\r\n        }\r\n    }, styleSheetLoadTimeout);\r\n    link.addEventListener('load', () => {\r\n        clearTimeout(timer);\r\n        fired = true;\r\n        listener();\r\n    });\r\n}\r\nfunction serializeNode(n, options) {\r\n    const { doc, mirror, blockClass, blockSelector, unblockSelector, maskAllText, maskAttributeFn, maskTextClass, unmaskTextClass, maskTextSelector, unmaskTextSelector, inlineStylesheet, maskInputOptions = {}, maskTextFn, maskInputFn, dataURLOptions = {}, inlineImages, recordCanvas, keepIframeSrcFn, newlyAddedElement = false, } = options;\r\n    const rootId = getRootId(doc, mirror);\r\n    switch (n.nodeType) {\r\n        case n.DOCUMENT_NODE:\r\n            if (n.compatMode !== 'CSS1Compat') {\r\n                return {\r\n                    type: NodeType.Document,\r\n                    childNodes: [],\r\n                    compatMode: n.compatMode,\r\n                };\r\n            }\r\n            else {\r\n                return {\r\n                    type: NodeType.Document,\r\n                    childNodes: [],\r\n                };\r\n            }\r\n        case n.DOCUMENT_TYPE_NODE:\r\n            return {\r\n                type: NodeType.DocumentType,\r\n                name: n.name,\r\n                publicId: n.publicId,\r\n                systemId: n.systemId,\r\n                rootId,\r\n            };\r\n        case n.ELEMENT_NODE:\r\n            return serializeElementNode(n, {\r\n                doc,\r\n                blockClass,\r\n                blockSelector,\r\n                unblockSelector,\r\n                inlineStylesheet,\r\n                maskAttributeFn,\r\n                maskInputOptions,\r\n                maskInputFn,\r\n                dataURLOptions,\r\n                inlineImages,\r\n                recordCanvas,\r\n                keepIframeSrcFn,\r\n                newlyAddedElement,\r\n                rootId,\r\n                maskAllText,\r\n                maskTextClass,\r\n                unmaskTextClass,\r\n                maskTextSelector,\r\n                unmaskTextSelector,\r\n            });\r\n        case n.TEXT_NODE:\r\n            return serializeTextNode(n, {\r\n                doc,\r\n                maskAllText,\r\n                maskTextClass,\r\n                unmaskTextClass,\r\n                maskTextSelector,\r\n                unmaskTextSelector,\r\n                maskTextFn,\r\n                maskInputOptions,\r\n                maskInputFn,\r\n                rootId,\r\n            });\r\n        case n.CDATA_SECTION_NODE:\r\n            return {\r\n                type: NodeType.CDATA,\r\n                textContent: '',\r\n                rootId,\r\n            };\r\n        case n.COMMENT_NODE:\r\n            return {\r\n                type: NodeType.Comment,\r\n                textContent: n.textContent || '',\r\n                rootId,\r\n            };\r\n        default:\r\n            return false;\r\n    }\r\n}\r\nfunction getRootId(doc, mirror) {\r\n    if (!mirror.hasNode(doc))\r\n        return undefined;\r\n    const docId = mirror.getId(doc);\r\n    return docId === 1 ? undefined : docId;\r\n}\r\nfunction serializeTextNode(n, options) {\r\n    const { maskAllText, maskTextClass, unmaskTextClass, maskTextSelector, unmaskTextSelector, maskTextFn, maskInputOptions, maskInputFn, rootId, } = options;\r\n    const parentTagName = n.parentNode && n.parentNode.tagName;\r\n    let textContent = n.textContent;\r\n    const isStyle = parentTagName === 'STYLE' ? true : undefined;\r\n    const isScript = parentTagName === 'SCRIPT' ? true : undefined;\r\n    const isTextarea = parentTagName === 'TEXTAREA' ? true : undefined;\r\n    if (isStyle && textContent) {\r\n        try {\r\n            if (n.nextSibling || n.previousSibling) {\r\n            }\r\n            else if (n.parentNode.sheet?.cssRules) {\r\n                textContent = stringifyStylesheet(n.parentNode.sheet);\r\n            }\r\n        }\r\n        catch (err) {\r\n            console.warn(`Cannot get CSS styles from text's parentNode. Error: ${err}`, n);\r\n        }\r\n        textContent = absoluteToStylesheet(textContent, getHref(options.doc));\r\n    }\r\n    if (isScript) {\r\n        textContent = 'SCRIPT_PLACEHOLDER';\r\n    }\r\n    const forceMask = needMaskingText(n, maskTextClass, maskTextSelector, unmaskTextClass, unmaskTextSelector, maskAllText);\r\n    if (!isStyle && !isScript && !isTextarea && textContent && forceMask) {\r\n        textContent = maskTextFn\r\n            ? maskTextFn(textContent, n.parentElement)\r\n            : textContent.replace(/[\\S]/g, '*');\r\n    }\r\n    if (isTextarea && textContent && (maskInputOptions.textarea || forceMask)) {\r\n        textContent = maskInputFn\r\n            ? maskInputFn(textContent, n.parentNode)\r\n            : textContent.replace(/[\\S]/g, '*');\r\n    }\r\n    if (parentTagName === 'OPTION' && textContent) {\r\n        const isInputMasked = shouldMaskInput({\r\n            type: null,\r\n            tagName: parentTagName,\r\n            maskInputOptions,\r\n        });\r\n        textContent = maskInputValue({\r\n            isMasked: needMaskingText(n, maskTextClass, maskTextSelector, unmaskTextClass, unmaskTextSelector, isInputMasked),\r\n            element: n,\r\n            value: textContent,\r\n            maskInputFn,\r\n        });\r\n    }\r\n    return {\r\n        type: NodeType.Text,\r\n        textContent: textContent || '',\r\n        isStyle,\r\n        rootId,\r\n    };\r\n}\r\nfunction serializeElementNode(n, options) {\r\n    const { doc, blockClass, blockSelector, unblockSelector, inlineStylesheet, maskInputOptions = {}, maskAttributeFn, maskInputFn, dataURLOptions = {}, inlineImages, recordCanvas, keepIframeSrcFn, newlyAddedElement = false, rootId, maskAllText, maskTextClass, unmaskTextClass, maskTextSelector, unmaskTextSelector, } = options;\r\n    const needBlock = _isBlockedElement(n, blockClass, blockSelector, unblockSelector);\r\n    const tagName = getValidTagName(n);\r\n    let attributes = {};\r\n    const len = n.attributes.length;\r\n    for (let i = 0; i < len; i++) {\r\n        const attr = n.attributes[i];\r\n        if (attr.name && !ignoreAttribute(tagName, attr.name, attr.value)) {\r\n            attributes[attr.name] = transformAttribute(doc, tagName, toLowerCase(attr.name), attr.value, n, maskAttributeFn);\r\n        }\r\n    }\r\n    if (tagName === 'link' && inlineStylesheet) {\r\n        const stylesheet = Array.from(doc.styleSheets).find((s) => {\r\n            return s.href === n.href;\r\n        });\r\n        let cssText = null;\r\n        if (stylesheet) {\r\n            cssText = stringifyStylesheet(stylesheet);\r\n        }\r\n        if (cssText) {\r\n            attributes.rel = null;\r\n            attributes.href = null;\r\n            attributes.crossorigin = null;\r\n            attributes._cssText = absoluteToStylesheet(cssText, stylesheet.href);\r\n        }\r\n    }\r\n    if (tagName === 'style' &&\r\n        n.sheet &&\r\n        !(n.innerText || n.textContent || '').trim().length) {\r\n        const cssText = stringifyStylesheet(n.sheet);\r\n        if (cssText) {\r\n            attributes._cssText = absoluteToStylesheet(cssText, getHref(doc));\r\n        }\r\n    }\r\n    if (tagName === 'input' ||\r\n        tagName === 'textarea' ||\r\n        tagName === 'select' ||\r\n        tagName === 'option') {\r\n        const el = n;\r\n        const type = getInputType(el);\r\n        const value = getInputValue(el, toUpperCase(tagName), type);\r\n        const checked = el.checked;\r\n        if (type !== 'submit' && type !== 'button' && value) {\r\n            const forceMask = needMaskingText(el, maskTextClass, maskTextSelector, unmaskTextClass, unmaskTextSelector, shouldMaskInput({\r\n                type,\r\n                tagName: toUpperCase(tagName),\r\n                maskInputOptions,\r\n            }));\r\n            attributes.value = maskInputValue({\r\n                isMasked: forceMask,\r\n                element: el,\r\n                value,\r\n                maskInputFn,\r\n            });\r\n        }\r\n        if (checked) {\r\n            attributes.checked = checked;\r\n        }\r\n    }\r\n    if (tagName === 'option') {\r\n        if (n.selected && !maskInputOptions['select']) {\r\n            attributes.selected = true;\r\n        }\r\n        else {\r\n            delete attributes.selected;\r\n        }\r\n    }\r\n    if (tagName === 'canvas' && recordCanvas) {\r\n        if (n.__context === '2d') {\r\n            if (!is2DCanvasBlank(n)) {\r\n                attributes.rr_dataURL = n.toDataURL(dataURLOptions.type, dataURLOptions.quality);\r\n            }\r\n        }\r\n        else if (!('__context' in n)) {\r\n            const canvasDataURL = n.toDataURL(dataURLOptions.type, dataURLOptions.quality);\r\n            const blankCanvas = doc.createElement('canvas');\r\n            blankCanvas.width = n.width;\r\n            blankCanvas.height = n.height;\r\n            const blankCanvasDataURL = blankCanvas.toDataURL(dataURLOptions.type, dataURLOptions.quality);\r\n            if (canvasDataURL !== blankCanvasDataURL) {\r\n                attributes.rr_dataURL = canvasDataURL;\r\n            }\r\n        }\r\n    }\r\n    if (tagName === 'img' && inlineImages) {\r\n        if (!canvasService) {\r\n            canvasService = doc.createElement('canvas');\r\n            canvasCtx = canvasService.getContext('2d');\r\n        }\r\n        const image = n;\r\n        const imageSrc = image.currentSrc || image.getAttribute('src') || '<unknown-src>';\r\n        const priorCrossOrigin = image.crossOrigin;\r\n        const recordInlineImage = () => {\r\n            image.removeEventListener('load', recordInlineImage);\r\n            try {\r\n                canvasService.width = image.naturalWidth;\r\n                canvasService.height = image.naturalHeight;\r\n                canvasCtx.drawImage(image, 0, 0);\r\n                attributes.rr_dataURL = canvasService.toDataURL(dataURLOptions.type, dataURLOptions.quality);\r\n            }\r\n            catch (err) {\r\n                if (image.crossOrigin !== 'anonymous') {\r\n                    image.crossOrigin = 'anonymous';\r\n                    if (image.complete && image.naturalWidth !== 0)\r\n                        recordInlineImage();\r\n                    else\r\n                        image.addEventListener('load', recordInlineImage);\r\n                    return;\r\n                }\r\n                else {\r\n                    console.warn(`Cannot inline img src=${imageSrc}! Error: ${err}`);\r\n                }\r\n            }\r\n            if (image.crossOrigin === 'anonymous') {\r\n                priorCrossOrigin\r\n                    ? (attributes.crossOrigin = priorCrossOrigin)\r\n                    : image.removeAttribute('crossorigin');\r\n            }\r\n        };\r\n        if (image.complete && image.naturalWidth !== 0)\r\n            recordInlineImage();\r\n        else\r\n            image.addEventListener('load', recordInlineImage);\r\n    }\r\n    if (tagName === 'audio' || tagName === 'video') {\r\n        attributes.rr_mediaState = n.paused\r\n            ? 'paused'\r\n            : 'played';\r\n        attributes.rr_mediaCurrentTime = n.currentTime;\r\n    }\r\n    if (!newlyAddedElement) {\r\n        if (n.scrollLeft) {\r\n            attributes.rr_scrollLeft = n.scrollLeft;\r\n        }\r\n        if (n.scrollTop) {\r\n            attributes.rr_scrollTop = n.scrollTop;\r\n        }\r\n    }\r\n    if (needBlock) {\r\n        const { width, height } = n.getBoundingClientRect();\r\n        attributes = {\r\n            class: attributes.class,\r\n            rr_width: `${width}px`,\r\n            rr_height: `${height}px`,\r\n        };\r\n    }\r\n    if (tagName === 'iframe' && !keepIframeSrcFn(attributes.src)) {\r\n        if (!needBlock && !getIframeContentDocument(n)) {\r\n            attributes.rr_src = attributes.src;\r\n        }\r\n        delete attributes.src;\r\n    }\r\n    let isCustomElement;\r\n    try {\r\n        if (customElements.get(tagName))\r\n            isCustomElement = true;\r\n    }\r\n    catch (e) {\r\n    }\r\n    return {\r\n        type: NodeType.Element,\r\n        tagName,\r\n        attributes,\r\n        childNodes: [],\r\n        isSVG: isSVGElement(n) || undefined,\r\n        needBlock,\r\n        rootId,\r\n        isCustom: isCustomElement,\r\n    };\r\n}\r\nfunction lowerIfExists(maybeAttr) {\r\n    if (maybeAttr === undefined || maybeAttr === null) {\r\n        return '';\r\n    }\r\n    else {\r\n        return maybeAttr.toLowerCase();\r\n    }\r\n}\r\nfunction slimDOMExcluded(sn, slimDOMOptions) {\r\n    if (slimDOMOptions.comment && sn.type === NodeType.Comment) {\r\n        return true;\r\n    }\r\n    else if (sn.type === NodeType.Element) {\r\n        if (slimDOMOptions.script &&\r\n            (sn.tagName === 'script' ||\r\n                (sn.tagName === 'link' &&\r\n                    (sn.attributes.rel === 'preload' ||\r\n                        sn.attributes.rel === 'modulepreload')) ||\r\n                (sn.tagName === 'link' &&\r\n                    sn.attributes.rel === 'prefetch' &&\r\n                    typeof sn.attributes.href === 'string' &&\r\n                    extractFileExtension(sn.attributes.href) === 'js'))) {\r\n            return true;\r\n        }\r\n        else if (slimDOMOptions.headFavicon &&\r\n            ((sn.tagName === 'link' && sn.attributes.rel === 'shortcut icon') ||\r\n                (sn.tagName === 'meta' &&\r\n                    (lowerIfExists(sn.attributes.name).match(/^msapplication-tile(image|color)$/) ||\r\n                        lowerIfExists(sn.attributes.name) === 'application-name' ||\r\n                        lowerIfExists(sn.attributes.rel) === 'icon' ||\r\n                        lowerIfExists(sn.attributes.rel) === 'apple-touch-icon' ||\r\n                        lowerIfExists(sn.attributes.rel) === 'shortcut icon')))) {\r\n            return true;\r\n        }\r\n        else if (sn.tagName === 'meta') {\r\n            if (slimDOMOptions.headMetaDescKeywords &&\r\n                lowerIfExists(sn.attributes.name).match(/^description|keywords$/)) {\r\n                return true;\r\n            }\r\n            else if (slimDOMOptions.headMetaSocial &&\r\n                (lowerIfExists(sn.attributes.property).match(/^(og|twitter|fb):/) ||\r\n                    lowerIfExists(sn.attributes.name).match(/^(og|twitter):/) ||\r\n                    lowerIfExists(sn.attributes.name) === 'pinterest')) {\r\n                return true;\r\n            }\r\n            else if (slimDOMOptions.headMetaRobots &&\r\n                (lowerIfExists(sn.attributes.name) === 'robots' ||\r\n                    lowerIfExists(sn.attributes.name) === 'googlebot' ||\r\n                    lowerIfExists(sn.attributes.name) === 'bingbot')) {\r\n                return true;\r\n            }\r\n            else if (slimDOMOptions.headMetaHttpEquiv &&\r\n                sn.attributes['http-equiv'] !== undefined) {\r\n                return true;\r\n            }\r\n            else if (slimDOMOptions.headMetaAuthorship &&\r\n                (lowerIfExists(sn.attributes.name) === 'author' ||\r\n                    lowerIfExists(sn.attributes.name) === 'generator' ||\r\n                    lowerIfExists(sn.attributes.name) === 'framework' ||\r\n                    lowerIfExists(sn.attributes.name) === 'publisher' ||\r\n                    lowerIfExists(sn.attributes.name) === 'progid' ||\r\n                    lowerIfExists(sn.attributes.property).match(/^article:/) ||\r\n                    lowerIfExists(sn.attributes.property).match(/^product:/))) {\r\n                return true;\r\n            }\r\n            else if (slimDOMOptions.headMetaVerification &&\r\n                (lowerIfExists(sn.attributes.name) === 'google-site-verification' ||\r\n                    lowerIfExists(sn.attributes.name) === 'yandex-verification' ||\r\n                    lowerIfExists(sn.attributes.name) === 'csrf-token' ||\r\n                    lowerIfExists(sn.attributes.name) === 'p:domain_verify' ||\r\n                    lowerIfExists(sn.attributes.name) === 'verify-v1' ||\r\n                    lowerIfExists(sn.attributes.name) === 'verification' ||\r\n                    lowerIfExists(sn.attributes.name) === 'shopify-checkout-api-token')) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}\r\nfunction serializeNodeWithId(n, options) {\r\n    const { doc, mirror, blockClass, blockSelector, unblockSelector, maskAllText, maskTextClass, unmaskTextClass, maskTextSelector, unmaskTextSelector, skipChild = false, inlineStylesheet = true, maskInputOptions = {}, maskAttributeFn, maskTextFn, maskInputFn, slimDOMOptions, dataURLOptions = {}, inlineImages = false, recordCanvas = false, onSerialize, onIframeLoad, iframeLoadTimeout = 5000, onStylesheetLoad, stylesheetLoadTimeout = 5000, keepIframeSrcFn = () => false, newlyAddedElement = false, } = options;\r\n    let { preserveWhiteSpace = true } = options;\r\n    const _serializedNode = serializeNode(n, {\r\n        doc,\r\n        mirror,\r\n        blockClass,\r\n        blockSelector,\r\n        maskAllText,\r\n        unblockSelector,\r\n        maskTextClass,\r\n        unmaskTextClass,\r\n        maskTextSelector,\r\n        unmaskTextSelector,\r\n        inlineStylesheet,\r\n        maskInputOptions,\r\n        maskAttributeFn,\r\n        maskTextFn,\r\n        maskInputFn,\r\n        dataURLOptions,\r\n        inlineImages,\r\n        recordCanvas,\r\n        keepIframeSrcFn,\r\n        newlyAddedElement,\r\n    });\r\n    if (!_serializedNode) {\r\n        console.warn(n, 'not serialized');\r\n        return null;\r\n    }\r\n    let id;\r\n    if (mirror.hasNode(n)) {\r\n        id = mirror.getId(n);\r\n    }\r\n    else if (slimDOMExcluded(_serializedNode, slimDOMOptions) ||\r\n        (!preserveWhiteSpace &&\r\n            _serializedNode.type === NodeType.Text &&\r\n            !_serializedNode.isStyle &&\r\n            !_serializedNode.textContent.replace(/^\\s+|\\s+$/gm, '').length)) {\r\n        id = IGNORED_NODE;\r\n    }\r\n    else {\r\n        id = genId();\r\n    }\r\n    const serializedNode = Object.assign(_serializedNode, { id });\r\n    mirror.add(n, serializedNode);\r\n    if (id === IGNORED_NODE) {\r\n        return null;\r\n    }\r\n    if (onSerialize) {\r\n        onSerialize(n);\r\n    }\r\n    let recordChild = !skipChild;\r\n    if (serializedNode.type === NodeType.Element) {\r\n        recordChild = recordChild && !serializedNode.needBlock;\r\n        delete serializedNode.needBlock;\r\n        const shadowRoot = n.shadowRoot;\r\n        if (shadowRoot && isNativeShadowDom(shadowRoot))\r\n            serializedNode.isShadowHost = true;\r\n    }\r\n    if ((serializedNode.type === NodeType.Document ||\r\n        serializedNode.type === NodeType.Element) &&\r\n        recordChild) {\r\n        if (slimDOMOptions.headWhitespace &&\r\n            serializedNode.type === NodeType.Element &&\r\n            serializedNode.tagName === 'head') {\r\n            preserveWhiteSpace = false;\r\n        }\r\n        const bypassOptions = {\r\n            doc,\r\n            mirror,\r\n            blockClass,\r\n            blockSelector,\r\n            maskAllText,\r\n            unblockSelector,\r\n            maskTextClass,\r\n            unmaskTextClass,\r\n            maskTextSelector,\r\n            unmaskTextSelector,\r\n            skipChild,\r\n            inlineStylesheet,\r\n            maskInputOptions,\r\n            maskAttributeFn,\r\n            maskTextFn,\r\n            maskInputFn,\r\n            slimDOMOptions,\r\n            dataURLOptions,\r\n            inlineImages,\r\n            recordCanvas,\r\n            preserveWhiteSpace,\r\n            onSerialize,\r\n            onIframeLoad,\r\n            iframeLoadTimeout,\r\n            onStylesheetLoad,\r\n            stylesheetLoadTimeout,\r\n            keepIframeSrcFn,\r\n        };\r\n        for (const childN of Array.from(n.childNodes)) {\r\n            const serializedChildNode = serializeNodeWithId(childN, bypassOptions);\r\n            if (serializedChildNode) {\r\n                serializedNode.childNodes.push(serializedChildNode);\r\n            }\r\n        }\r\n        if (isElement(n) && n.shadowRoot) {\r\n            for (const childN of Array.from(n.shadowRoot.childNodes)) {\r\n                const serializedChildNode = serializeNodeWithId(childN, bypassOptions);\r\n                if (serializedChildNode) {\r\n                    isNativeShadowDom(n.shadowRoot) &&\r\n                        (serializedChildNode.isShadow = true);\r\n                    serializedNode.childNodes.push(serializedChildNode);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (n.parentNode &&\r\n        isShadowRoot(n.parentNode) &&\r\n        isNativeShadowDom(n.parentNode)) {\r\n        serializedNode.isShadow = true;\r\n    }\r\n    if (serializedNode.type === NodeType.Element &&\r\n        serializedNode.tagName === 'iframe') {\r\n        onceIframeLoaded(n, () => {\r\n            const iframeDoc = getIframeContentDocument(n);\r\n            if (iframeDoc && onIframeLoad) {\r\n                const serializedIframeNode = serializeNodeWithId(iframeDoc, {\r\n                    doc: iframeDoc,\r\n                    mirror,\r\n                    blockClass,\r\n                    blockSelector,\r\n                    unblockSelector,\r\n                    maskAllText,\r\n                    maskTextClass,\r\n                    unmaskTextClass,\r\n                    maskTextSelector,\r\n                    unmaskTextSelector,\r\n                    skipChild: false,\r\n                    inlineStylesheet,\r\n                    maskInputOptions,\r\n                    maskAttributeFn,\r\n                    maskTextFn,\r\n                    maskInputFn,\r\n                    slimDOMOptions,\r\n                    dataURLOptions,\r\n                    inlineImages,\r\n                    recordCanvas,\r\n                    preserveWhiteSpace,\r\n                    onSerialize,\r\n                    onIframeLoad,\r\n                    iframeLoadTimeout,\r\n                    onStylesheetLoad,\r\n                    stylesheetLoadTimeout,\r\n                    keepIframeSrcFn,\r\n                });\r\n                if (serializedIframeNode) {\r\n                    onIframeLoad(n, serializedIframeNode);\r\n                }\r\n            }\r\n        }, iframeLoadTimeout);\r\n    }\r\n    if (serializedNode.type === NodeType.Element &&\r\n        serializedNode.tagName === 'link' &&\r\n        typeof serializedNode.attributes.rel === 'string' &&\r\n        (serializedNode.attributes.rel === 'stylesheet' ||\r\n            (serializedNode.attributes.rel === 'preload' &&\r\n                typeof serializedNode.attributes.href === 'string' &&\r\n                extractFileExtension(serializedNode.attributes.href) === 'css'))) {\r\n        onceStylesheetLoaded(n, () => {\r\n            if (onStylesheetLoad) {\r\n                const serializedLinkNode = serializeNodeWithId(n, {\r\n                    doc,\r\n                    mirror,\r\n                    blockClass,\r\n                    blockSelector,\r\n                    unblockSelector,\r\n                    maskAllText,\r\n                    maskTextClass,\r\n                    unmaskTextClass,\r\n                    maskTextSelector,\r\n                    unmaskTextSelector,\r\n                    skipChild: false,\r\n                    inlineStylesheet,\r\n                    maskInputOptions,\r\n                    maskAttributeFn,\r\n                    maskTextFn,\r\n                    maskInputFn,\r\n                    slimDOMOptions,\r\n                    dataURLOptions,\r\n                    inlineImages,\r\n                    recordCanvas,\r\n                    preserveWhiteSpace,\r\n                    onSerialize,\r\n                    onIframeLoad,\r\n                    iframeLoadTimeout,\r\n                    onStylesheetLoad,\r\n                    stylesheetLoadTimeout,\r\n                    keepIframeSrcFn,\r\n                });\r\n                if (serializedLinkNode) {\r\n                    onStylesheetLoad(n, serializedLinkNode);\r\n                }\r\n            }\r\n        }, stylesheetLoadTimeout);\r\n    }\r\n    return serializedNode;\r\n}\r\nfunction snapshot(n, options) {\r\n    const { mirror = new Mirror(), blockClass = 'rr-block', blockSelector = null, unblockSelector = null, maskAllText = false, maskTextClass = 'rr-mask', unmaskTextClass = null, maskTextSelector = null, unmaskTextSelector = null, inlineStylesheet = true, inlineImages = false, recordCanvas = false, maskAllInputs = false, maskAttributeFn, maskTextFn, maskInputFn, slimDOM = false, dataURLOptions, preserveWhiteSpace, onSerialize, onIframeLoad, iframeLoadTimeout, onStylesheetLoad, stylesheetLoadTimeout, keepIframeSrcFn = () => false, } = options || {};\r\n    const maskInputOptions = maskAllInputs === true\r\n        ? {\r\n            color: true,\r\n            date: true,\r\n            'datetime-local': true,\r\n            email: true,\r\n            month: true,\r\n            number: true,\r\n            range: true,\r\n            search: true,\r\n            tel: true,\r\n            text: true,\r\n            time: true,\r\n            url: true,\r\n            week: true,\r\n            textarea: true,\r\n            select: true,\r\n        }\r\n        : maskAllInputs === false\r\n            ? {}\r\n            : maskAllInputs;\r\n    const slimDOMOptions = slimDOM === true || slimDOM === 'all'\r\n        ?\r\n            {\r\n                script: true,\r\n                comment: true,\r\n                headFavicon: true,\r\n                headWhitespace: true,\r\n                headMetaDescKeywords: slimDOM === 'all',\r\n                headMetaSocial: true,\r\n                headMetaRobots: true,\r\n                headMetaHttpEquiv: true,\r\n                headMetaAuthorship: true,\r\n                headMetaVerification: true,\r\n            }\r\n        : slimDOM === false\r\n            ? {}\r\n            : slimDOM;\r\n    return serializeNodeWithId(n, {\r\n        doc: n,\r\n        mirror,\r\n        blockClass,\r\n        blockSelector,\r\n        unblockSelector,\r\n        maskAllText,\r\n        maskTextClass,\r\n        unmaskTextClass,\r\n        maskTextSelector,\r\n        unmaskTextSelector,\r\n        skipChild: false,\r\n        inlineStylesheet,\r\n        maskInputOptions,\r\n        maskAttributeFn,\r\n        maskTextFn,\r\n        maskInputFn,\r\n        slimDOMOptions,\r\n        dataURLOptions,\r\n        inlineImages,\r\n        recordCanvas,\r\n        preserveWhiteSpace,\r\n        onSerialize,\r\n        onIframeLoad,\r\n        iframeLoadTimeout,\r\n        onStylesheetLoad,\r\n        stylesheetLoadTimeout,\r\n        keepIframeSrcFn,\r\n        newlyAddedElement: false,\r\n    });\r\n}\r\n\nconst commentre = /\\/\\*[^*]*\\*+([^/*][^*]*\\*+)*\\//g;\r\nfunction parse(css, options = {}) {\r\n    let lineno = 1;\r\n    let column = 1;\r\n    function updatePosition(str) {\r\n        const lines = str.match(/\\n/g);\r\n        if (lines) {\r\n            lineno += lines.length;\r\n        }\r\n        const i = str.lastIndexOf('\\n');\r\n        column = i === -1 ? column + str.length : str.length - i;\r\n    }\r\n    function position() {\r\n        const start = { line: lineno, column };\r\n        return (node) => {\r\n            node.position = new Position(start);\r\n            whitespace();\r\n            return node;\r\n        };\r\n    }\r\n    class Position {\r\n        constructor(start) {\r\n            this.start = start;\r\n            this.end = { line: lineno, column };\r\n            this.source = options.source;\r\n        }\r\n    }\r\n    Position.prototype.content = css;\r\n    const errorsList = [];\r\n    function error(msg) {\r\n        const err = new Error(`${options.source || ''}:${lineno}:${column}: ${msg}`);\r\n        err.reason = msg;\r\n        err.filename = options.source;\r\n        err.line = lineno;\r\n        err.column = column;\r\n        err.source = css;\r\n        if (options.silent) {\r\n            errorsList.push(err);\r\n        }\r\n        else {\r\n            throw err;\r\n        }\r\n    }\r\n    function stylesheet() {\r\n        const rulesList = rules();\r\n        return {\r\n            type: 'stylesheet',\r\n            stylesheet: {\r\n                source: options.source,\r\n                rules: rulesList,\r\n                parsingErrors: errorsList,\r\n            },\r\n        };\r\n    }\r\n    function open() {\r\n        return match(/^{\\s*/);\r\n    }\r\n    function close() {\r\n        return match(/^}/);\r\n    }\r\n    function rules() {\r\n        let node;\r\n        const rules = [];\r\n        whitespace();\r\n        comments(rules);\r\n        while (css.length && css.charAt(0) !== '}' && (node = atrule() || rule())) {\r\n            if (node) {\r\n                rules.push(node);\r\n                comments(rules);\r\n            }\r\n        }\r\n        return rules;\r\n    }\r\n    function match(re) {\r\n        const m = re.exec(css);\r\n        if (!m) {\r\n            return;\r\n        }\r\n        const str = m[0];\r\n        updatePosition(str);\r\n        css = css.slice(str.length);\r\n        return m;\r\n    }\r\n    function whitespace() {\r\n        match(/^\\s*/);\r\n    }\r\n    function comments(rules = []) {\r\n        let c;\r\n        while ((c = comment())) {\r\n            if (c) {\r\n                rules.push(c);\r\n            }\r\n            c = comment();\r\n        }\r\n        return rules;\r\n    }\r\n    function comment() {\r\n        const pos = position();\r\n        if ('/' !== css.charAt(0) || '*' !== css.charAt(1)) {\r\n            return;\r\n        }\r\n        let i = 2;\r\n        while ('' !== css.charAt(i) &&\r\n            ('*' !== css.charAt(i) || '/' !== css.charAt(i + 1))) {\r\n            ++i;\r\n        }\r\n        i += 2;\r\n        if ('' === css.charAt(i - 1)) {\r\n            return error('End of comment missing');\r\n        }\r\n        const str = css.slice(2, i - 2);\r\n        column += 2;\r\n        updatePosition(str);\r\n        css = css.slice(i);\r\n        column += 2;\r\n        return pos({\r\n            type: 'comment',\r\n            comment: str,\r\n        });\r\n    }\r\n    function selector() {\r\n        const m = match(/^([^{]+)/);\r\n        if (!m) {\r\n            return;\r\n        }\r\n        const splitSelectors = trim(m[0])\r\n            .replace(/\\/\\*([^*]|[\\r\\n]|(\\*+([^*/]|[\\r\\n])))*\\*\\/+/g, '')\r\n            .replace(/\"(?:\\\\\"|[^\"])*\"|'(?:\\\\'|[^'])*'/g, (m) => {\r\n            return m.replace(/,/g, '\\u200C');\r\n        })\r\n            .split(/\\s*(?![^(]*\\)),\\s*/);\r\n        if (splitSelectors.length <= 1) {\r\n            return splitSelectors.map((s) => {\r\n                return s.replace(/\\u200C/g, ',');\r\n            });\r\n        }\r\n        let i = 0;\r\n        let j = 0;\r\n        const len = splitSelectors.length;\r\n        const finalSelectors = [];\r\n        while (i < len) {\r\n            const openingParensCount = (splitSelectors[i].match(/\\(/g) || []).length;\r\n            const closingParensCount = (splitSelectors[i].match(/\\)/g) || []).length;\r\n            let unbalancedParens = openingParensCount - closingParensCount;\r\n            if (unbalancedParens >= 1) {\r\n                let foundClosingSelector = false;\r\n                j = i + 1;\r\n                while (j < len) {\r\n                    const nextOpeningParensCount = (splitSelectors[j].match(/\\(/g) || [])\r\n                        .length;\r\n                    const nextClosingParensCount = (splitSelectors[j].match(/\\)/g) || [])\r\n                        .length;\r\n                    const nextUnbalancedParens = nextClosingParensCount - nextOpeningParensCount;\r\n                    if (nextUnbalancedParens === unbalancedParens) {\r\n                        finalSelectors.push(splitSelectors.slice(i, j + 1).join(','));\r\n                        i = j + 1;\r\n                        foundClosingSelector = true;\r\n                        break;\r\n                    }\r\n                    j++;\r\n                    unbalancedParens -= nextUnbalancedParens;\r\n                }\r\n                if (foundClosingSelector) {\r\n                    continue;\r\n                }\r\n                splitSelectors\r\n                    .slice(i, len)\r\n                    .forEach((selector) => selector && finalSelectors.push(selector));\r\n                break;\r\n            }\r\n            splitSelectors[i] && finalSelectors.push(splitSelectors[i]);\r\n            i++;\r\n        }\r\n        return finalSelectors.map((s) => {\r\n            return s.replace(/\\u200C/g, ',');\r\n        });\r\n    }\r\n    function declaration() {\r\n        const pos = position();\r\n        const propMatch = match(/^(\\*?[-#\\/\\*\\\\\\w]+(\\[[0-9a-z_-]+\\])?)\\s*/);\r\n        if (!propMatch) {\r\n            return;\r\n        }\r\n        const prop = trim(propMatch[0]);\r\n        if (!match(/^:\\s*/)) {\r\n            return error(`property missing ':'`);\r\n        }\r\n        const val = match(/^((?:'(?:\\\\'|.)*?'|\"(?:\\\\\"|.)*?\"|\\([^\\)]*?\\)|[^};])+)/);\r\n        const ret = pos({\r\n            type: 'declaration',\r\n            property: prop.replace(commentre, ''),\r\n            value: val ? trim(val[0]).replace(commentre, '') : '',\r\n        });\r\n        match(/^[;\\s]*/);\r\n        return ret;\r\n    }\r\n    function declarations() {\r\n        const decls = [];\r\n        if (!open()) {\r\n            return error(`missing '{'`);\r\n        }\r\n        comments(decls);\r\n        let decl;\r\n        while ((decl = declaration())) {\r\n            if (decl !== false) {\r\n                decls.push(decl);\r\n                comments(decls);\r\n            }\r\n            decl = declaration();\r\n        }\r\n        if (!close()) {\r\n            return error(`missing '}'`);\r\n        }\r\n        return decls;\r\n    }\r\n    function keyframe() {\r\n        let m;\r\n        const vals = [];\r\n        const pos = position();\r\n        while ((m = match(/^((\\d+\\.\\d+|\\.\\d+|\\d+)%?|[a-z]+)\\s*/))) {\r\n            vals.push(m[1]);\r\n            match(/^,\\s*/);\r\n        }\r\n        if (!vals.length) {\r\n            return;\r\n        }\r\n        return pos({\r\n            type: 'keyframe',\r\n            values: vals,\r\n            declarations: declarations(),\r\n        });\r\n    }\r\n    function atkeyframes() {\r\n        const pos = position();\r\n        let m = match(/^@([-\\w]+)?keyframes\\s*/);\r\n        if (!m) {\r\n            return;\r\n        }\r\n        const vendor = m[1];\r\n        m = match(/^([-\\w]+)\\s*/);\r\n        if (!m) {\r\n            return error('@keyframes missing name');\r\n        }\r\n        const name = m[1];\r\n        if (!open()) {\r\n            return error(`@keyframes missing '{'`);\r\n        }\r\n        let frame;\r\n        let frames = comments();\r\n        while ((frame = keyframe())) {\r\n            frames.push(frame);\r\n            frames = frames.concat(comments());\r\n        }\r\n        if (!close()) {\r\n            return error(`@keyframes missing '}'`);\r\n        }\r\n        return pos({\r\n            type: 'keyframes',\r\n            name,\r\n            vendor,\r\n            keyframes: frames,\r\n        });\r\n    }\r\n    function atsupports() {\r\n        const pos = position();\r\n        const m = match(/^@supports *([^{]+)/);\r\n        if (!m) {\r\n            return;\r\n        }\r\n        const supports = trim(m[1]);\r\n        if (!open()) {\r\n            return error(`@supports missing '{'`);\r\n        }\r\n        const style = comments().concat(rules());\r\n        if (!close()) {\r\n            return error(`@supports missing '}'`);\r\n        }\r\n        return pos({\r\n            type: 'supports',\r\n            supports,\r\n            rules: style,\r\n        });\r\n    }\r\n    function athost() {\r\n        const pos = position();\r\n        const m = match(/^@host\\s*/);\r\n        if (!m) {\r\n            return;\r\n        }\r\n        if (!open()) {\r\n            return error(`@host missing '{'`);\r\n        }\r\n        const style = comments().concat(rules());\r\n        if (!close()) {\r\n            return error(`@host missing '}'`);\r\n        }\r\n        return pos({\r\n            type: 'host',\r\n            rules: style,\r\n        });\r\n    }\r\n    function atmedia() {\r\n        const pos = position();\r\n        const m = match(/^@media *([^{]+)/);\r\n        if (!m) {\r\n            return;\r\n        }\r\n        const media = trim(m[1]);\r\n        if (!open()) {\r\n            return error(`@media missing '{'`);\r\n        }\r\n        const style = comments().concat(rules());\r\n        if (!close()) {\r\n            return error(`@media missing '}'`);\r\n        }\r\n        return pos({\r\n            type: 'media',\r\n            media,\r\n            rules: style,\r\n        });\r\n    }\r\n    function atcustommedia() {\r\n        const pos = position();\r\n        const m = match(/^@custom-media\\s+(--[^\\s]+)\\s*([^{;]+);/);\r\n        if (!m) {\r\n            return;\r\n        }\r\n        return pos({\r\n            type: 'custom-media',\r\n            name: trim(m[1]),\r\n            media: trim(m[2]),\r\n        });\r\n    }\r\n    function atpage() {\r\n        const pos = position();\r\n        const m = match(/^@page */);\r\n        if (!m) {\r\n            return;\r\n        }\r\n        const sel = selector() || [];\r\n        if (!open()) {\r\n            return error(`@page missing '{'`);\r\n        }\r\n        let decls = comments();\r\n        let decl;\r\n        while ((decl = declaration())) {\r\n            decls.push(decl);\r\n            decls = decls.concat(comments());\r\n        }\r\n        if (!close()) {\r\n            return error(`@page missing '}'`);\r\n        }\r\n        return pos({\r\n            type: 'page',\r\n            selectors: sel,\r\n            declarations: decls,\r\n        });\r\n    }\r\n    function atdocument() {\r\n        const pos = position();\r\n        const m = match(/^@([-\\w]+)?document *([^{]+)/);\r\n        if (!m) {\r\n            return;\r\n        }\r\n        const vendor = trim(m[1]);\r\n        const doc = trim(m[2]);\r\n        if (!open()) {\r\n            return error(`@document missing '{'`);\r\n        }\r\n        const style = comments().concat(rules());\r\n        if (!close()) {\r\n            return error(`@document missing '}'`);\r\n        }\r\n        return pos({\r\n            type: 'document',\r\n            document: doc,\r\n            vendor,\r\n            rules: style,\r\n        });\r\n    }\r\n    function atfontface() {\r\n        const pos = position();\r\n        const m = match(/^@font-face\\s*/);\r\n        if (!m) {\r\n            return;\r\n        }\r\n        if (!open()) {\r\n            return error(`@font-face missing '{'`);\r\n        }\r\n        let decls = comments();\r\n        let decl;\r\n        while ((decl = declaration())) {\r\n            decls.push(decl);\r\n            decls = decls.concat(comments());\r\n        }\r\n        if (!close()) {\r\n            return error(`@font-face missing '}'`);\r\n        }\r\n        return pos({\r\n            type: 'font-face',\r\n            declarations: decls,\r\n        });\r\n    }\r\n    const atimport = _compileAtrule('import');\r\n    const atcharset = _compileAtrule('charset');\r\n    const atnamespace = _compileAtrule('namespace');\r\n    function _compileAtrule(name) {\r\n        const re = new RegExp('^@' +\r\n            name +\r\n            '\\\\s*((?:' +\r\n            [\r\n                /[^\\\\]\"(?:\\\\\"|[^\"])*\"/.source,\r\n                /[^\\\\]'(?:\\\\'|[^'])*'/.source,\r\n                '[^;]',\r\n            ].join('|') +\r\n            ')+);');\r\n        return () => {\r\n            const pos = position();\r\n            const m = match(re);\r\n            if (!m) {\r\n                return;\r\n            }\r\n            const ret = { type: name };\r\n            ret[name] = m[1].trim();\r\n            return pos(ret);\r\n        };\r\n    }\r\n    function atrule() {\r\n        if (css[0] !== '@') {\r\n            return;\r\n        }\r\n        return (atkeyframes() ||\r\n            atmedia() ||\r\n            atcustommedia() ||\r\n            atsupports() ||\r\n            atimport() ||\r\n            atcharset() ||\r\n            atnamespace() ||\r\n            atdocument() ||\r\n            atpage() ||\r\n            athost() ||\r\n            atfontface());\r\n    }\r\n    function rule() {\r\n        const pos = position();\r\n        const sel = selector();\r\n        if (!sel) {\r\n            return error('selector missing');\r\n        }\r\n        comments();\r\n        return pos({\r\n            type: 'rule',\r\n            selectors: sel,\r\n            declarations: declarations(),\r\n        });\r\n    }\r\n    return addParent(stylesheet());\r\n}\r\nfunction trim(str) {\r\n    return str ? str.replace(/^\\s+|\\s+$/g, '') : '';\r\n}\r\nfunction addParent(obj, parent) {\r\n    const isNode = obj && typeof obj.type === 'string';\r\n    const childParent = isNode ? obj : parent;\r\n    for (const k of Object.keys(obj)) {\r\n        const value = obj[k];\r\n        if (Array.isArray(value)) {\r\n            value.forEach((v) => {\r\n                addParent(v, childParent);\r\n            });\r\n        }\r\n        else if (value && typeof value === 'object') {\r\n            addParent(value, childParent);\r\n        }\r\n    }\r\n    if (isNode) {\r\n        Object.defineProperty(obj, 'parent', {\r\n            configurable: true,\r\n            writable: true,\r\n            enumerable: false,\r\n            value: parent || null,\r\n        });\r\n    }\r\n    return obj;\r\n}\n\nconst tagMap = {\r\n    script: 'noscript',\r\n    altglyph: 'altGlyph',\r\n    altglyphdef: 'altGlyphDef',\r\n    altglyphitem: 'altGlyphItem',\r\n    animatecolor: 'animateColor',\r\n    animatemotion: 'animateMotion',\r\n    animatetransform: 'animateTransform',\r\n    clippath: 'clipPath',\r\n    feblend: 'feBlend',\r\n    fecolormatrix: 'feColorMatrix',\r\n    fecomponenttransfer: 'feComponentTransfer',\r\n    fecomposite: 'feComposite',\r\n    feconvolvematrix: 'feConvolveMatrix',\r\n    fediffuselighting: 'feDiffuseLighting',\r\n    fedisplacementmap: 'feDisplacementMap',\r\n    fedistantlight: 'feDistantLight',\r\n    fedropshadow: 'feDropShadow',\r\n    feflood: 'feFlood',\r\n    fefunca: 'feFuncA',\r\n    fefuncb: 'feFuncB',\r\n    fefuncg: 'feFuncG',\r\n    fefuncr: 'feFuncR',\r\n    fegaussianblur: 'feGaussianBlur',\r\n    feimage: 'feImage',\r\n    femerge: 'feMerge',\r\n    femergenode: 'feMergeNode',\r\n    femorphology: 'feMorphology',\r\n    feoffset: 'feOffset',\r\n    fepointlight: 'fePointLight',\r\n    fespecularlighting: 'feSpecularLighting',\r\n    fespotlight: 'feSpotLight',\r\n    fetile: 'feTile',\r\n    feturbulence: 'feTurbulence',\r\n    foreignobject: 'foreignObject',\r\n    glyphref: 'glyphRef',\r\n    lineargradient: 'linearGradient',\r\n    radialgradient: 'radialGradient',\r\n};\r\nfunction getTagName(n) {\r\n    let tagName = tagMap[n.tagName] ? tagMap[n.tagName] : n.tagName;\r\n    if (tagName === 'link' && n.attributes._cssText) {\r\n        tagName = 'style';\r\n    }\r\n    return tagName;\r\n}\r\nfunction escapeRegExp(str) {\r\n    return str.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\r\n}\r\nconst HOVER_SELECTOR = /([^\\\\]):hover/;\r\nconst HOVER_SELECTOR_GLOBAL = new RegExp(HOVER_SELECTOR.source, 'g');\r\nfunction addHoverClass(cssText, cache) {\r\n    const cachedStyle = cache?.stylesWithHoverClass.get(cssText);\r\n    if (cachedStyle)\r\n        return cachedStyle;\r\n    if (cssText.length >= 1000000) {\r\n        return cssText;\r\n    }\r\n    const ast = parse(cssText, {\r\n        silent: true,\r\n    });\r\n    if (!ast.stylesheet) {\r\n        return cssText;\r\n    }\r\n    const selectors = [];\r\n    ast.stylesheet.rules.forEach((rule) => {\r\n        if ('selectors' in rule) {\r\n            (rule.selectors || []).forEach((selector) => {\r\n                if (HOVER_SELECTOR.test(selector)) {\r\n                    selectors.push(selector);\r\n                }\r\n            });\r\n        }\r\n    });\r\n    if (selectors.length === 0) {\r\n        return cssText;\r\n    }\r\n    const selectorMatcher = new RegExp(selectors\r\n        .filter((selector, index) => selectors.indexOf(selector) === index)\r\n        .sort((a, b) => b.length - a.length)\r\n        .map((selector) => {\r\n        return escapeRegExp(selector);\r\n    })\r\n        .join('|'), 'g');\r\n    const result = cssText.replace(selectorMatcher, (selector) => {\r\n        const newSelector = selector.replace(HOVER_SELECTOR_GLOBAL, '$1.\\\\:hover');\r\n        return `${selector}, ${newSelector}`;\r\n    });\r\n    cache?.stylesWithHoverClass.set(cssText, result);\r\n    return result;\r\n}\r\nfunction createCache() {\r\n    const stylesWithHoverClass = new Map();\r\n    return {\r\n        stylesWithHoverClass,\r\n    };\r\n}\r\nfunction buildNode(n, options) {\r\n    const { doc, hackCss, cache } = options;\r\n    switch (n.type) {\r\n        case NodeType.Document:\r\n            return doc.implementation.createDocument(null, '', null);\r\n        case NodeType.DocumentType:\r\n            return doc.implementation.createDocumentType(n.name || 'html', n.publicId, n.systemId);\r\n        case NodeType.Element: {\r\n            const tagName = getTagName(n);\r\n            let node;\r\n            if (n.isSVG) {\r\n                node = doc.createElementNS('http://www.w3.org/2000/svg', tagName);\r\n            }\r\n            else {\r\n                if (n.isCustom &&\r\n                    doc.defaultView?.customElements &&\r\n                    !doc.defaultView.customElements.get(n.tagName))\r\n                    doc.defaultView.customElements.define(n.tagName, class extends doc.defaultView.HTMLElement {\r\n                    });\r\n                node = doc.createElement(tagName);\r\n            }\r\n            const specialAttributes = {};\r\n            for (const name in n.attributes) {\r\n                if (!Object.prototype.hasOwnProperty.call(n.attributes, name)) {\r\n                    continue;\r\n                }\r\n                let value = n.attributes[name];\r\n                if (tagName === 'option' &&\r\n                    name === 'selected' &&\r\n                    value === false) {\r\n                    continue;\r\n                }\r\n                if (value === null) {\r\n                    continue;\r\n                }\r\n                if (value === true)\r\n                    value = '';\r\n                if (name.startsWith('rr_')) {\r\n                    specialAttributes[name] = value;\r\n                    continue;\r\n                }\r\n                const isTextarea = tagName === 'textarea' && name === 'value';\r\n                const isRemoteOrDynamicCss = tagName === 'style' && name === '_cssText';\r\n                if (isRemoteOrDynamicCss && hackCss && typeof value === 'string') {\r\n                    value = addHoverClass(value, cache);\r\n                }\r\n                if ((isTextarea || isRemoteOrDynamicCss) && typeof value === 'string') {\r\n                    const child = doc.createTextNode(value);\r\n                    for (const c of Array.from(node.childNodes)) {\r\n                        if (c.nodeType === node.TEXT_NODE) {\r\n                            node.removeChild(c);\r\n                        }\r\n                    }\r\n                    node.appendChild(child);\r\n                    continue;\r\n                }\r\n                try {\r\n                    if (n.isSVG && name === 'xlink:href') {\r\n                        node.setAttributeNS('http://www.w3.org/1999/xlink', name, value.toString());\r\n                    }\r\n                    else if (name === 'onload' ||\r\n                        name === 'onclick' ||\r\n                        name.substring(0, 7) === 'onmouse') {\r\n                        node.setAttribute('_' + name, value.toString());\r\n                    }\r\n                    else if (tagName === 'meta' &&\r\n                        n.attributes['http-equiv'] === 'Content-Security-Policy' &&\r\n                        name === 'content') {\r\n                        node.setAttribute('csp-content', value.toString());\r\n                        continue;\r\n                    }\r\n                    else if (tagName === 'link' &&\r\n                        (n.attributes.rel === 'preload' ||\r\n                            n.attributes.rel === 'modulepreload')) {\r\n                    }\r\n                    else if (tagName === 'link' &&\r\n                        n.attributes.rel === 'prefetch' &&\r\n                        typeof n.attributes.href === 'string' &&\r\n                        extractFileExtension(n.attributes.href) === 'js') {\r\n                    }\r\n                    else if (tagName === 'img' &&\r\n                        n.attributes.srcset &&\r\n                        n.attributes.rr_dataURL) {\r\n                        node.setAttribute('rrweb-original-srcset', n.attributes.srcset);\r\n                    }\r\n                    else {\r\n                        node.setAttribute(name, value.toString());\r\n                    }\r\n                }\r\n                catch (error) {\r\n                }\r\n            }\r\n            for (const name in specialAttributes) {\r\n                const value = specialAttributes[name];\r\n                if (tagName === 'canvas' && name === 'rr_dataURL') {\r\n                    const image = doc.createElement('img');\r\n                    image.onload = () => {\r\n                        const ctx = node.getContext('2d');\r\n                        if (ctx) {\r\n                            ctx.drawImage(image, 0, 0, image.width, image.height);\r\n                        }\r\n                    };\r\n                    image.src = value.toString();\r\n                    if (node.RRNodeType)\r\n                        node.rr_dataURL = value.toString();\r\n                }\r\n                else if (tagName === 'img' && name === 'rr_dataURL') {\r\n                    const image = node;\r\n                    if (!image.currentSrc.startsWith('data:')) {\r\n                        image.setAttribute('rrweb-original-src', n.attributes.src);\r\n                        image.src = value.toString();\r\n                    }\r\n                }\r\n                if (name === 'rr_width') {\r\n                    node.style.setProperty('width', value.toString());\r\n                }\r\n                else if (name === 'rr_height') {\r\n                    node.style.setProperty('height', value.toString());\r\n                }\r\n                else if (name === 'rr_mediaCurrentTime' &&\r\n                    typeof value === 'number') {\r\n                    node.currentTime = value;\r\n                }\r\n                else if (name === 'rr_mediaState') {\r\n                    switch (value) {\r\n                        case 'played':\r\n                            node\r\n                                .play()\r\n                                .catch((e) => console.warn('media playback error', e));\r\n                            break;\r\n                        case 'paused':\r\n                            node.pause();\r\n                            break;\r\n                    }\r\n                }\r\n            }\r\n            if (n.isShadowHost) {\r\n                if (!node.shadowRoot) {\r\n                    node.attachShadow({ mode: 'open' });\r\n                }\r\n                else {\r\n                    while (node.shadowRoot.firstChild) {\r\n                        node.shadowRoot.removeChild(node.shadowRoot.firstChild);\r\n                    }\r\n                }\r\n            }\r\n            return node;\r\n        }\r\n        case NodeType.Text:\r\n            return doc.createTextNode(n.isStyle && hackCss\r\n                ? addHoverClass(n.textContent, cache)\r\n                : n.textContent);\r\n        case NodeType.CDATA:\r\n            return doc.createCDATASection(n.textContent);\r\n        case NodeType.Comment:\r\n            return doc.createComment(n.textContent);\r\n        default:\r\n            return null;\r\n    }\r\n}\r\nfunction buildNodeWithSN(n, options) {\r\n    const { doc, mirror, skipChild = false, hackCss = true, afterAppend, cache, } = options;\r\n    if (mirror.has(n.id)) {\r\n        const nodeInMirror = mirror.getNode(n.id);\r\n        const meta = mirror.getMeta(nodeInMirror);\r\n        if (isNodeMetaEqual(meta, n))\r\n            return mirror.getNode(n.id);\r\n    }\r\n    let node = buildNode(n, { doc, hackCss, cache });\r\n    if (!node) {\r\n        return null;\r\n    }\r\n    if (n.rootId && mirror.getNode(n.rootId) !== doc) {\r\n        mirror.replace(n.rootId, doc);\r\n    }\r\n    if (n.type === NodeType.Document) {\r\n        doc.close();\r\n        doc.open();\r\n        if (n.compatMode === 'BackCompat' &&\r\n            n.childNodes &&\r\n            n.childNodes[0].type !== NodeType.DocumentType) {\r\n            if (n.childNodes[0].type === NodeType.Element &&\r\n                'xmlns' in n.childNodes[0].attributes &&\r\n                n.childNodes[0].attributes.xmlns === 'http://www.w3.org/1999/xhtml') {\r\n                doc.write('<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"\">');\r\n            }\r\n            else {\r\n                doc.write('<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.0 Transitional//EN\" \"\">');\r\n            }\r\n        }\r\n        node = doc;\r\n    }\r\n    mirror.add(node, n);\r\n    if ((n.type === NodeType.Document || n.type === NodeType.Element) &&\r\n        !skipChild) {\r\n        for (const childN of n.childNodes) {\r\n            const childNode = buildNodeWithSN(childN, {\r\n                doc,\r\n                mirror,\r\n                skipChild: false,\r\n                hackCss,\r\n                afterAppend,\r\n                cache,\r\n            });\r\n            if (!childNode) {\r\n                console.warn('Failed to rebuild', childN);\r\n                continue;\r\n            }\r\n            if (childN.isShadow && isElement(node) && node.shadowRoot) {\r\n                node.shadowRoot.appendChild(childNode);\r\n            }\r\n            else if (n.type === NodeType.Document &&\r\n                childN.type == NodeType.Element) {\r\n                const htmlElement = childNode;\r\n                let body = null;\r\n                htmlElement.childNodes.forEach((child) => {\r\n                    if (child.nodeName === 'BODY')\r\n                        body = child;\r\n                });\r\n                if (body) {\r\n                    htmlElement.removeChild(body);\r\n                    node.appendChild(childNode);\r\n                    htmlElement.appendChild(body);\r\n                }\r\n                else {\r\n                    node.appendChild(childNode);\r\n                }\r\n            }\r\n            else {\r\n                node.appendChild(childNode);\r\n            }\r\n            if (afterAppend) {\r\n                afterAppend(childNode, childN.id);\r\n            }\r\n        }\r\n    }\r\n    return node;\r\n}\r\nfunction visit(mirror, onVisit) {\r\n    function walk(node) {\r\n        onVisit(node);\r\n    }\r\n    for (const id of mirror.getIds()) {\r\n        if (mirror.has(id)) {\r\n            walk(mirror.getNode(id));\r\n        }\r\n    }\r\n}\r\nfunction handleScroll(node, mirror) {\r\n    const n = mirror.getMeta(node);\r\n    if (n?.type !== NodeType.Element) {\r\n        return;\r\n    }\r\n    const el = node;\r\n    for (const name in n.attributes) {\r\n        if (!(Object.prototype.hasOwnProperty.call(n.attributes, name) &&\r\n            name.startsWith('rr_'))) {\r\n            continue;\r\n        }\r\n        const value = n.attributes[name];\r\n        if (name === 'rr_scrollLeft') {\r\n            el.scrollLeft = value;\r\n        }\r\n        if (name === 'rr_scrollTop') {\r\n            el.scrollTop = value;\r\n        }\r\n    }\r\n}\r\nfunction rebuild(n, options) {\r\n    const { doc, onVisit, hackCss = true, afterAppend, cache, mirror = new Mirror(), } = options;\r\n    const node = buildNodeWithSN(n, {\r\n        doc,\r\n        mirror,\r\n        skipChild: false,\r\n        hackCss,\r\n        afterAppend,\r\n        cache,\r\n    });\r\n    visit(mirror, (visitedNode) => {\r\n        if (onVisit) {\r\n            onVisit(visitedNode);\r\n        }\r\n        handleScroll(visitedNode, mirror);\r\n    });\r\n    return node;\r\n}\n\nexport { IGNORED_NODE, Mirror, NodeType, addHoverClass, buildNodeWithSN, clearTimeout, createCache, createMatchPredicate, createMirror, distanceToMatch, escapeImportStatement, extractFileExtension, fixAllCssProperty, fixSafariColons, genId, getIframeContentDocument, getInputType, getInputValue, ignoreAttribute, is2DCanvasBlank, isCSSImportRule, isCSSStyleRule, isElement, isNativeShadowDom, isNodeMetaEqual, isShadowRoot, maskInputValue, needMaskingText, rebuild, serializeNodeWithId, setTimeout, shouldMaskInput, snapshot, stringifyRule, stringifyStylesheet, toLowerCase, toUpperCase, transformAttribute };\n","import { distanceToMatch, IGNORED_NODE, isShadowRoot, createMatchPredicate } from '../../rrweb-snapshot/es/rrweb-snapshot.js';\n\nfunction on(type, fn, target = document) {\r\n    const options = { capture: true, passive: true };\r\n    target.addEventListener(type, fn, options);\r\n    return () => target.removeEventListener(type, fn, options);\r\n}\r\nconst DEPARTED_MIRROR_ACCESS_WARNING = 'Please stop import mirror directly. Instead of that,' +\r\n    '\\r\\n' +\r\n    'now you can use replayer.getMirror() to access the mirror instance of a replayer,' +\r\n    '\\r\\n' +\r\n    'or you can use record.mirror to access the mirror instance during recording.';\r\nlet _mirror = {\r\n    map: {},\r\n    getId() {\r\n        console.error(DEPARTED_MIRROR_ACCESS_WARNING);\r\n        return -1;\r\n    },\r\n    getNode() {\r\n        console.error(DEPARTED_MIRROR_ACCESS_WARNING);\r\n        return null;\r\n    },\r\n    removeNodeFromMap() {\r\n        console.error(DEPARTED_MIRROR_ACCESS_WARNING);\r\n    },\r\n    has() {\r\n        console.error(DEPARTED_MIRROR_ACCESS_WARNING);\r\n        return false;\r\n    },\r\n    reset() {\r\n        console.error(DEPARTED_MIRROR_ACCESS_WARNING);\r\n    },\r\n};\r\nif (typeof window !== 'undefined' && window.Proxy && window.Reflect) {\r\n    _mirror = new Proxy(_mirror, {\r\n        get(target, prop, receiver) {\r\n            if (prop === 'map') {\r\n                console.error(DEPARTED_MIRROR_ACCESS_WARNING);\r\n            }\r\n            return Reflect.get(target, prop, receiver);\r\n        },\r\n    });\r\n}\r\nfunction throttle(func, wait, options = {}) {\r\n    let timeout = null;\r\n    let previous = 0;\r\n    return function (...args) {\r\n        const now = Date.now();\r\n        if (!previous && options.leading === false) {\r\n            previous = now;\r\n        }\r\n        const remaining = wait - (now - previous);\r\n        const context = this;\r\n        if (remaining <= 0 || remaining > wait) {\r\n            if (timeout) {\r\n                clearTimeout(timeout);\r\n                timeout = null;\r\n            }\r\n            previous = now;\r\n            func.apply(context, args);\r\n        }\r\n        else if (!timeout && options.trailing !== false) {\r\n            timeout = setTimeout(() => {\r\n                previous = options.leading === false ? 0 : Date.now();\r\n                timeout = null;\r\n                func.apply(context, args);\r\n            }, remaining);\r\n        }\r\n    };\r\n}\r\nfunction hookSetter(target, key, d, isRevoked, win = window) {\r\n    const original = win.Object.getOwnPropertyDescriptor(target, key);\r\n    win.Object.defineProperty(target, key, isRevoked\r\n        ? d\r\n        : {\r\n            set(value) {\r\n                setTimeout(() => {\r\n                    d.set.call(this, value);\r\n                }, 0);\r\n                if (original && original.set) {\r\n                    original.set.call(this, value);\r\n                }\r\n            },\r\n        });\r\n    return () => hookSetter(target, key, original || {}, true);\r\n}\r\nfunction patch(source, name, replacement) {\r\n    try {\r\n        if (!(name in source)) {\r\n            return () => {\r\n            };\r\n        }\r\n        const original = source[name];\r\n        const wrapped = replacement(original);\r\n        if (typeof wrapped === 'function') {\r\n            wrapped.prototype = wrapped.prototype || {};\r\n            Object.defineProperties(wrapped, {\r\n                __rrweb_original__: {\r\n                    enumerable: false,\r\n                    value: original,\r\n                },\r\n            });\r\n        }\r\n        source[name] = wrapped;\r\n        return () => {\r\n            source[name] = original;\r\n        };\r\n    }\r\n    catch {\r\n        return () => {\r\n        };\r\n    }\r\n}\r\nlet nowTimestamp = Date.now;\r\nif (!(/[1-9][0-9]{12}/.test(Date.now().toString()))) {\r\n    nowTimestamp = () => new Date().getTime();\r\n}\r\nfunction getWindowScroll(win) {\r\n    const doc = win.document;\r\n    return {\r\n        left: doc.scrollingElement\r\n            ? doc.scrollingElement.scrollLeft\r\n            : win.pageXOffset !== undefined\r\n                ? win.pageXOffset\r\n                : doc?.documentElement.scrollLeft ||\r\n                    doc?.body?.parentElement?.scrollLeft ||\r\n                    doc?.body?.scrollLeft ||\r\n                    0,\r\n        top: doc.scrollingElement\r\n            ? doc.scrollingElement.scrollTop\r\n            : win.pageYOffset !== undefined\r\n                ? win.pageYOffset\r\n                : doc?.documentElement.scrollTop ||\r\n                    doc?.body?.parentElement?.scrollTop ||\r\n                    doc?.body?.scrollTop ||\r\n                    0,\r\n    };\r\n}\r\nfunction getWindowHeight() {\r\n    return (window.innerHeight ||\r\n        (document.documentElement && document.documentElement.clientHeight) ||\r\n        (document.body && document.body.clientHeight));\r\n}\r\nfunction getWindowWidth() {\r\n    return (window.innerWidth ||\r\n        (document.documentElement && document.documentElement.clientWidth) ||\r\n        (document.body && document.body.clientWidth));\r\n}\r\nfunction closestElementOfNode(node) {\r\n    if (!node) {\r\n        return null;\r\n    }\r\n    const el = node.nodeType === node.ELEMENT_NODE\r\n        ? node\r\n        : node.parentElement;\r\n    return el;\r\n}\r\nfunction isBlocked(node, blockClass, blockSelector, unblockSelector, checkAncestors) {\r\n    if (!node) {\r\n        return false;\r\n    }\r\n    const el = closestElementOfNode(node);\r\n    if (!el) {\r\n        return false;\r\n    }\r\n    const blockedPredicate = createMatchPredicate(blockClass, blockSelector);\r\n    if (!checkAncestors) {\r\n        const isUnblocked = unblockSelector && el.matches(unblockSelector);\r\n        return blockedPredicate(el) && !isUnblocked;\r\n    }\r\n    const blockDistance = distanceToMatch(el, blockedPredicate);\r\n    let unblockDistance = -1;\r\n    if (blockDistance < 0) {\r\n        return false;\r\n    }\r\n    if (unblockSelector) {\r\n        unblockDistance = distanceToMatch(el, createMatchPredicate(null, unblockSelector));\r\n    }\r\n    if (blockDistance > -1 && unblockDistance < 0) {\r\n        return true;\r\n    }\r\n    return blockDistance < unblockDistance;\r\n}\r\nfunction isSerialized(n, mirror) {\r\n    return mirror.getId(n) !== -1;\r\n}\r\nfunction isIgnored(n, mirror) {\r\n    return mirror.getId(n) === IGNORED_NODE;\r\n}\r\nfunction isAncestorRemoved(target, mirror) {\r\n    if (isShadowRoot(target)) {\r\n        return false;\r\n    }\r\n    const id = mirror.getId(target);\r\n    if (!mirror.has(id)) {\r\n        return true;\r\n    }\r\n    if (target.parentNode &&\r\n        target.parentNode.nodeType === target.DOCUMENT_NODE) {\r\n        return false;\r\n    }\r\n    if (!target.parentNode) {\r\n        return true;\r\n    }\r\n    return isAncestorRemoved(target.parentNode, mirror);\r\n}\r\nfunction legacy_isTouchEvent(event) {\r\n    return Boolean(event.changedTouches);\r\n}\r\nfunction polyfill(win = window) {\r\n    if ('NodeList' in win && !win.NodeList.prototype.forEach) {\r\n        win.NodeList.prototype.forEach = Array.prototype\r\n            .forEach;\r\n    }\r\n    if ('DOMTokenList' in win && !win.DOMTokenList.prototype.forEach) {\r\n        win.DOMTokenList.prototype.forEach = Array.prototype\r\n            .forEach;\r\n    }\r\n    if (!Node.prototype.contains) {\r\n        Node.prototype.contains = (...args) => {\r\n            let node = args[0];\r\n            if (!(0 in args)) {\r\n                throw new TypeError('1 argument is required');\r\n            }\r\n            do {\r\n                if (this === node) {\r\n                    return true;\r\n                }\r\n            } while ((node = node && node.parentNode));\r\n            return false;\r\n        };\r\n    }\r\n}\r\nfunction queueToResolveTrees(queue) {\r\n    const queueNodeMap = {};\r\n    const putIntoMap = (m, parent) => {\r\n        const nodeInTree = {\r\n            value: m,\r\n            parent,\r\n            children: [],\r\n        };\r\n        queueNodeMap[m.node.id] = nodeInTree;\r\n        return nodeInTree;\r\n    };\r\n    const queueNodeTrees = [];\r\n    for (const mutation of queue) {\r\n        const { nextId, parentId } = mutation;\r\n        if (nextId && nextId in queueNodeMap) {\r\n            const nextInTree = queueNodeMap[nextId];\r\n            if (nextInTree.parent) {\r\n                const idx = nextInTree.parent.children.indexOf(nextInTree);\r\n                nextInTree.parent.children.splice(idx, 0, putIntoMap(mutation, nextInTree.parent));\r\n            }\r\n            else {\r\n                const idx = queueNodeTrees.indexOf(nextInTree);\r\n                queueNodeTrees.splice(idx, 0, putIntoMap(mutation, null));\r\n            }\r\n            continue;\r\n        }\r\n        if (parentId in queueNodeMap) {\r\n            const parentInTree = queueNodeMap[parentId];\r\n            parentInTree.children.push(putIntoMap(mutation, parentInTree));\r\n            continue;\r\n        }\r\n        queueNodeTrees.push(putIntoMap(mutation, null));\r\n    }\r\n    return queueNodeTrees;\r\n}\r\nfunction iterateResolveTree(tree, cb) {\r\n    cb(tree.value);\r\n    for (let i = tree.children.length - 1; i >= 0; i--) {\r\n        iterateResolveTree(tree.children[i], cb);\r\n    }\r\n}\r\nfunction isSerializedIframe(n, mirror) {\r\n    return Boolean(n.nodeName === 'IFRAME' && mirror.getMeta(n));\r\n}\r\nfunction isSerializedStylesheet(n, mirror) {\r\n    return Boolean(n.nodeName === 'LINK' &&\r\n        n.nodeType === n.ELEMENT_NODE &&\r\n        n.getAttribute &&\r\n        n.getAttribute('rel') === 'stylesheet' &&\r\n        mirror.getMeta(n));\r\n}\r\nfunction getBaseDimension(node, rootIframe) {\r\n    const frameElement = node.ownerDocument?.defaultView?.frameElement;\r\n    if (!frameElement || frameElement === rootIframe) {\r\n        return {\r\n            x: 0,\r\n            y: 0,\r\n            relativeScale: 1,\r\n            absoluteScale: 1,\r\n        };\r\n    }\r\n    const frameDimension = frameElement.getBoundingClientRect();\r\n    const frameBaseDimension = getBaseDimension(frameElement, rootIframe);\r\n    const relativeScale = frameDimension.height / frameElement.clientHeight;\r\n    return {\r\n        x: frameDimension.x * frameBaseDimension.relativeScale +\r\n            frameBaseDimension.x,\r\n        y: frameDimension.y * frameBaseDimension.relativeScale +\r\n            frameBaseDimension.y,\r\n        relativeScale,\r\n        absoluteScale: frameBaseDimension.absoluteScale * relativeScale,\r\n    };\r\n}\r\nfunction hasShadowRoot(n) {\r\n    return Boolean(n?.shadowRoot);\r\n}\r\nfunction getNestedRule(rules, position) {\r\n    const rule = rules[position[0]];\r\n    if (position.length === 1) {\r\n        return rule;\r\n    }\r\n    else {\r\n        return getNestedRule(rule.cssRules[position[1]].cssRules, position.slice(2));\r\n    }\r\n}\r\nfunction getPositionsAndIndex(nestedIndex) {\r\n    const positions = [...nestedIndex];\r\n    const index = positions.pop();\r\n    return { positions, index };\r\n}\r\nfunction uniqueTextMutations(mutations) {\r\n    const idSet = new Set();\r\n    const uniqueMutations = [];\r\n    for (let i = mutations.length; i--;) {\r\n        const mutation = mutations[i];\r\n        if (!idSet.has(mutation.id)) {\r\n            uniqueMutations.push(mutation);\r\n            idSet.add(mutation.id);\r\n        }\r\n    }\r\n    return uniqueMutations;\r\n}\r\nclass StyleSheetMirror {\r\n    constructor() {\r\n        this.id = 1;\r\n        this.styleIDMap = new WeakMap();\r\n        this.idStyleMap = new Map();\r\n    }\r\n    getId(stylesheet) {\r\n        return this.styleIDMap.get(stylesheet) ?? -1;\r\n    }\r\n    has(stylesheet) {\r\n        return this.styleIDMap.has(stylesheet);\r\n    }\r\n    add(stylesheet, id) {\r\n        if (this.has(stylesheet))\r\n            return this.getId(stylesheet);\r\n        let newId;\r\n        if (id === undefined) {\r\n            newId = this.id++;\r\n        }\r\n        else\r\n            newId = id;\r\n        this.styleIDMap.set(stylesheet, newId);\r\n        this.idStyleMap.set(newId, stylesheet);\r\n        return newId;\r\n    }\r\n    getStyle(id) {\r\n        return this.idStyleMap.get(id) || null;\r\n    }\r\n    reset() {\r\n        this.styleIDMap = new WeakMap();\r\n        this.idStyleMap = new Map();\r\n        this.id = 1;\r\n    }\r\n    generateId() {\r\n        return this.id++;\r\n    }\r\n}\r\nfunction getShadowHost(n) {\r\n    let shadowHost = null;\r\n    if (n.getRootNode?.()?.nodeType === Node.DOCUMENT_FRAGMENT_NODE &&\r\n        n.getRootNode().host)\r\n        shadowHost = n.getRootNode().host;\r\n    return shadowHost;\r\n}\r\nfunction getRootShadowHost(n) {\r\n    let rootShadowHost = n;\r\n    let shadowHost;\r\n    while ((shadowHost = getShadowHost(rootShadowHost)))\r\n        rootShadowHost = shadowHost;\r\n    return rootShadowHost;\r\n}\r\nfunction shadowHostInDom(n) {\r\n    const doc = n.ownerDocument;\r\n    if (!doc)\r\n        return false;\r\n    const shadowHost = getRootShadowHost(n);\r\n    return doc.contains(shadowHost);\r\n}\r\nfunction inDom(n) {\r\n    const doc = n.ownerDocument;\r\n    if (!doc)\r\n        return false;\r\n    return doc.contains(n) || shadowHostInDom(n);\r\n}\r\nconst cachedImplementations = {};\r\nfunction getImplementation(name) {\r\n    const cached = cachedImplementations[name];\r\n    if (cached) {\r\n        return cached;\r\n    }\r\n    const document = window.document;\r\n    let impl = window[name];\r\n    if (document && typeof document.createElement === 'function') {\r\n        try {\r\n            const sandbox = document.createElement('iframe');\r\n            sandbox.hidden = true;\r\n            document.head.appendChild(sandbox);\r\n            const contentWindow = sandbox.contentWindow;\r\n            if (contentWindow && contentWindow[name]) {\r\n                impl =\r\n                    contentWindow[name];\r\n            }\r\n            document.head.removeChild(sandbox);\r\n        }\r\n        catch (e) {\r\n        }\r\n    }\r\n    return (cachedImplementations[name] = impl.bind(window));\r\n}\r\nfunction onRequestAnimationFrame(...rest) {\r\n    return getImplementation('requestAnimationFrame')(...rest);\r\n}\r\nfunction setTimeout(...rest) {\r\n    return getImplementation('setTimeout')(...rest);\r\n}\r\nfunction clearTimeout(...rest) {\r\n    return getImplementation('clearTimeout')(...rest);\r\n}\n\nexport { StyleSheetMirror, _mirror, clearTimeout, closestElementOfNode, getBaseDimension, getNestedRule, getPositionsAndIndex, getRootShadowHost, getShadowHost, getWindowHeight, getWindowScroll, getWindowWidth, hasShadowRoot, hookSetter, inDom, isAncestorRemoved, isBlocked, isIgnored, isSerialized, isSerializedIframe, isSerializedStylesheet, iterateResolveTree, legacy_isTouchEvent, nowTimestamp, on, onRequestAnimationFrame, patch, polyfill, queueToResolveTrees, setTimeout, shadowHostInDom, throttle, uniqueTextMutations };\n","var EventType = /* @__PURE__ */ ((EventType2) => {\n  EventType2[EventType2[\"DomContentLoaded\"] = 0] = \"DomContentLoaded\";\n  EventType2[EventType2[\"Load\"] = 1] = \"Load\";\n  EventType2[EventType2[\"FullSnapshot\"] = 2] = \"FullSnapshot\";\n  EventType2[EventType2[\"IncrementalSnapshot\"] = 3] = \"IncrementalSnapshot\";\n  EventType2[EventType2[\"Meta\"] = 4] = \"Meta\";\n  EventType2[EventType2[\"Custom\"] = 5] = \"Custom\";\n  EventType2[EventType2[\"Plugin\"] = 6] = \"Plugin\";\n  return EventType2;\n})(EventType || {});\nvar IncrementalSource = /* @__PURE__ */ ((IncrementalSource2) => {\n  IncrementalSource2[IncrementalSource2[\"Mutation\"] = 0] = \"Mutation\";\n  IncrementalSource2[IncrementalSource2[\"MouseMove\"] = 1] = \"MouseMove\";\n  IncrementalSource2[IncrementalSource2[\"MouseInteraction\"] = 2] = \"MouseInteraction\";\n  IncrementalSource2[IncrementalSource2[\"Scroll\"] = 3] = \"Scroll\";\n  IncrementalSource2[IncrementalSource2[\"ViewportResize\"] = 4] = \"ViewportResize\";\n  IncrementalSource2[IncrementalSource2[\"Input\"] = 5] = \"Input\";\n  IncrementalSource2[IncrementalSource2[\"TouchMove\"] = 6] = \"TouchMove\";\n  IncrementalSource2[IncrementalSource2[\"MediaInteraction\"] = 7] = \"MediaInteraction\";\n  IncrementalSource2[IncrementalSource2[\"StyleSheetRule\"] = 8] = \"StyleSheetRule\";\n  IncrementalSource2[IncrementalSource2[\"CanvasMutation\"] = 9] = \"CanvasMutation\";\n  IncrementalSource2[IncrementalSource2[\"Font\"] = 10] = \"Font\";\n  IncrementalSource2[IncrementalSource2[\"Log\"] = 11] = \"Log\";\n  IncrementalSource2[IncrementalSource2[\"Drag\"] = 12] = \"Drag\";\n  IncrementalSource2[IncrementalSource2[\"StyleDeclaration\"] = 13] = \"StyleDeclaration\";\n  IncrementalSource2[IncrementalSource2[\"Selection\"] = 14] = \"Selection\";\n  IncrementalSource2[IncrementalSource2[\"AdoptedStyleSheet\"] = 15] = \"AdoptedStyleSheet\";\n  IncrementalSource2[IncrementalSource2[\"CustomElement\"] = 16] = \"CustomElement\";\n  return IncrementalSource2;\n})(IncrementalSource || {});\nvar MouseInteractions = /* @__PURE__ */ ((MouseInteractions2) => {\n  MouseInteractions2[MouseInteractions2[\"MouseUp\"] = 0] = \"MouseUp\";\n  MouseInteractions2[MouseInteractions2[\"MouseDown\"] = 1] = \"MouseDown\";\n  MouseInteractions2[MouseInteractions2[\"Click\"] = 2] = \"Click\";\n  MouseInteractions2[MouseInteractions2[\"ContextMenu\"] = 3] = \"ContextMenu\";\n  MouseInteractions2[MouseInteractions2[\"DblClick\"] = 4] = \"DblClick\";\n  MouseInteractions2[MouseInteractions2[\"Focus\"] = 5] = \"Focus\";\n  MouseInteractions2[MouseInteractions2[\"Blur\"] = 6] = \"Blur\";\n  MouseInteractions2[MouseInteractions2[\"TouchStart\"] = 7] = \"TouchStart\";\n  MouseInteractions2[MouseInteractions2[\"TouchMove_Departed\"] = 8] = \"TouchMove_Departed\";\n  MouseInteractions2[MouseInteractions2[\"TouchEnd\"] = 9] = \"TouchEnd\";\n  MouseInteractions2[MouseInteractions2[\"TouchCancel\"] = 10] = \"TouchCancel\";\n  return MouseInteractions2;\n})(MouseInteractions || {});\nvar PointerTypes = /* @__PURE__ */ ((PointerTypes2) => {\n  PointerTypes2[PointerTypes2[\"Mouse\"] = 0] = \"Mouse\";\n  PointerTypes2[PointerTypes2[\"Pen\"] = 1] = \"Pen\";\n  PointerTypes2[PointerTypes2[\"Touch\"] = 2] = \"Touch\";\n  return PointerTypes2;\n})(PointerTypes || {});\nvar CanvasContext = /* @__PURE__ */ ((CanvasContext2) => {\n  CanvasContext2[CanvasContext2[\"2D\"] = 0] = \"2D\";\n  CanvasContext2[CanvasContext2[\"WebGL\"] = 1] = \"WebGL\";\n  CanvasContext2[CanvasContext2[\"WebGL2\"] = 2] = \"WebGL2\";\n  return CanvasContext2;\n})(CanvasContext || {});\nvar ReplayerEvents = /* @__PURE__ */ ((ReplayerEvents2) => {\n  ReplayerEvents2[\"Start\"] = \"start\";\n  ReplayerEvents2[\"Pause\"] = \"pause\";\n  ReplayerEvents2[\"Resume\"] = \"resume\";\n  ReplayerEvents2[\"Resize\"] = \"resize\";\n  ReplayerEvents2[\"Finish\"] = \"finish\";\n  ReplayerEvents2[\"FullsnapshotRebuilded\"] = \"fullsnapshot-rebuilded\";\n  ReplayerEvents2[\"LoadStylesheetStart\"] = \"load-stylesheet-start\";\n  ReplayerEvents2[\"LoadStylesheetEnd\"] = \"load-stylesheet-end\";\n  ReplayerEvents2[\"SkipStart\"] = \"skip-start\";\n  ReplayerEvents2[\"SkipEnd\"] = \"skip-end\";\n  ReplayerEvents2[\"MouseInteraction\"] = \"mouse-interaction\";\n  ReplayerEvents2[\"EventCast\"] = \"event-cast\";\n  ReplayerEvents2[\"CustomEvent\"] = \"custom-event\";\n  ReplayerEvents2[\"Flush\"] = \"flush\";\n  ReplayerEvents2[\"StateChange\"] = \"state-change\";\n  ReplayerEvents2[\"PlayBack\"] = \"play-back\";\n  ReplayerEvents2[\"Destroy\"] = \"destroy\";\n  return ReplayerEvents2;\n})(ReplayerEvents || {});\n\nexport { CanvasContext, EventType, IncrementalSource, MouseInteractions, PointerTypes, ReplayerEvents };\n","let errorHandler;\r\nfunction registerErrorHandler(handler) {\r\n    errorHandler = handler;\r\n}\r\nfunction unregisterErrorHandler() {\r\n    errorHandler = undefined;\r\n}\r\nconst callbackWrapper = (cb) => {\r\n    if (!errorHandler) {\r\n        return cb;\r\n    }\r\n    const rrwebWrapped = ((...rest) => {\r\n        try {\r\n            return cb(...rest);\r\n        }\r\n        catch (error) {\r\n            if (errorHandler && errorHandler(error) === true) {\r\n                return () => {\r\n                };\r\n            }\r\n            throw error;\r\n        }\r\n    });\r\n    return rrwebWrapped;\r\n};\n\nexport { callbackWrapper, registerErrorHandler, unregisterErrorHandler };\n","/*\n * base64-arraybuffer 1.0.1 <https://github.com/niklasvh/base64-arraybuffer>\n * Copyright (c) 2021 Niklas von Hertzen <https://hertzen.com>\n * Released under MIT License\n */\nvar chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n// Use a lookup table to find the index.\nvar lookup = typeof Uint8Array === 'undefined' ? [] : new Uint8Array(256);\nfor (var i = 0; i < chars.length; i++) {\n    lookup[chars.charCodeAt(i)] = i;\n}\nvar encode = function (arraybuffer) {\n    var bytes = new Uint8Array(arraybuffer), i, len = bytes.length, base64 = '';\n    for (i = 0; i < len; i += 3) {\n        base64 += chars[bytes[i] >> 2];\n        base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];\n        base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];\n        base64 += chars[bytes[i + 2] & 63];\n    }\n    if (len % 3 === 2) {\n        base64 = base64.substring(0, base64.length - 1) + '=';\n    }\n    else if (len % 3 === 1) {\n        base64 = base64.substring(0, base64.length - 2) + '==';\n    }\n    return base64;\n};\nvar decode = function (base64) {\n    var bufferLength = base64.length * 0.75, len = base64.length, i, p = 0, encoded1, encoded2, encoded3, encoded4;\n    if (base64[base64.length - 1] === '=') {\n        bufferLength--;\n        if (base64[base64.length - 2] === '=') {\n            bufferLength--;\n        }\n    }\n    var arraybuffer = new ArrayBuffer(bufferLength), bytes = new Uint8Array(arraybuffer);\n    for (i = 0; i < len; i += 4) {\n        encoded1 = lookup[base64.charCodeAt(i)];\n        encoded2 = lookup[base64.charCodeAt(i + 1)];\n        encoded3 = lookup[base64.charCodeAt(i + 2)];\n        encoded4 = lookup[base64.charCodeAt(i + 3)];\n        bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);\n        bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);\n        bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);\n    }\n    return arraybuffer;\n};\n\nexport { decode, encode };\n","import { encode } from './../../../../../../ext/base64-arraybuffer/dist/base64-arraybuffer.es5.js';\n\nconst canvasVarMap = new Map();\r\nfunction variableListFor(ctx, ctor) {\r\n    let contextMap = canvasVarMap.get(ctx);\r\n    if (!contextMap) {\r\n        contextMap = new Map();\r\n        canvasVarMap.set(ctx, contextMap);\r\n    }\r\n    if (!contextMap.has(ctor)) {\r\n        contextMap.set(ctor, []);\r\n    }\r\n    return contextMap.get(ctor);\r\n}\r\nconst saveWebGLVar = (value, win, ctx) => {\r\n    if (!value ||\r\n        !(isInstanceOfWebGLObject(value, win) || typeof value === 'object'))\r\n        return;\r\n    const name = value.constructor.name;\r\n    const list = variableListFor(ctx, name);\r\n    let index = list.indexOf(value);\r\n    if (index === -1) {\r\n        index = list.length;\r\n        list.push(value);\r\n    }\r\n    return index;\r\n};\r\nfunction serializeArg(value, win, ctx) {\r\n    if (value instanceof Array) {\r\n        return value.map((arg) => serializeArg(arg, win, ctx));\r\n    }\r\n    else if (value === null) {\r\n        return value;\r\n    }\r\n    else if (value instanceof Float32Array ||\r\n        value instanceof Float64Array ||\r\n        value instanceof Int32Array ||\r\n        value instanceof Uint32Array ||\r\n        value instanceof Uint8Array ||\r\n        value instanceof Uint16Array ||\r\n        value instanceof Int16Array ||\r\n        value instanceof Int8Array ||\r\n        value instanceof Uint8ClampedArray) {\r\n        const name = value.constructor.name;\r\n        return {\r\n            rr_type: name,\r\n            args: [Object.values(value)],\r\n        };\r\n    }\r\n    else if (value instanceof ArrayBuffer) {\r\n        const name = value.constructor.name;\r\n        const base64 = encode(value);\r\n        return {\r\n            rr_type: name,\r\n            base64,\r\n        };\r\n    }\r\n    else if (value instanceof DataView) {\r\n        const name = value.constructor.name;\r\n        return {\r\n            rr_type: name,\r\n            args: [\r\n                serializeArg(value.buffer, win, ctx),\r\n                value.byteOffset,\r\n                value.byteLength,\r\n            ],\r\n        };\r\n    }\r\n    else if (value instanceof HTMLImageElement) {\r\n        const name = value.constructor.name;\r\n        const { src } = value;\r\n        return {\r\n            rr_type: name,\r\n            src,\r\n        };\r\n    }\r\n    else if (value instanceof HTMLCanvasElement) {\r\n        const name = 'HTMLImageElement';\r\n        const src = value.toDataURL();\r\n        return {\r\n            rr_type: name,\r\n            src,\r\n        };\r\n    }\r\n    else if (value instanceof ImageData) {\r\n        const name = value.constructor.name;\r\n        return {\r\n            rr_type: name,\r\n            args: [serializeArg(value.data, win, ctx), value.width, value.height],\r\n        };\r\n    }\r\n    else if (isInstanceOfWebGLObject(value, win) || typeof value === 'object') {\r\n        const name = value.constructor.name;\r\n        const index = saveWebGLVar(value, win, ctx);\r\n        return {\r\n            rr_type: name,\r\n            index: index,\r\n        };\r\n    }\r\n    return value;\r\n}\r\nconst serializeArgs = (args, win, ctx) => {\r\n    return args.map((arg) => serializeArg(arg, win, ctx));\r\n};\r\nconst isInstanceOfWebGLObject = (value, win) => {\r\n    const webGLConstructorNames = [\r\n        'WebGLActiveInfo',\r\n        'WebGLBuffer',\r\n        'WebGLFramebuffer',\r\n        'WebGLProgram',\r\n        'WebGLRenderbuffer',\r\n        'WebGLShader',\r\n        'WebGLShaderPrecisionFormat',\r\n        'WebGLTexture',\r\n        'WebGLUniformLocation',\r\n        'WebGLVertexArrayObject',\r\n        'WebGLVertexArrayObjectOES',\r\n    ];\r\n    const supportedWebGLConstructorNames = webGLConstructorNames.filter((name) => typeof win[name] === 'function');\r\n    return Boolean(supportedWebGLConstructorNames.find((name) => value instanceof win[name]));\r\n};\n\nexport { isInstanceOfWebGLObject, saveWebGLVar, serializeArg, serializeArgs, variableListFor };\n","import { CanvasContext } from '../../../../../types/dist/rrweb-types.js';\nimport { patch, isBlocked, setTimeout, hookSetter } from '../../../utils.js';\nimport { serializeArgs } from './serialize-args.js';\n\nfunction initCanvas2DMutationObserver(cb, win, blockClass, blockSelector, unblockSelector) {\r\n    const handlers = [];\r\n    const props2D = Object.getOwnPropertyNames(win.CanvasRenderingContext2D.prototype);\r\n    for (const prop of props2D) {\r\n        try {\r\n            if (typeof win.CanvasRenderingContext2D.prototype[prop] !== 'function') {\r\n                continue;\r\n            }\r\n            const restoreHandler = patch(win.CanvasRenderingContext2D.prototype, prop, function (original) {\r\n                return function (...args) {\r\n                    if (!isBlocked(this.canvas, blockClass, blockSelector, unblockSelector, true)) {\r\n                        setTimeout(() => {\r\n                            const recordArgs = serializeArgs(args, win, this);\r\n                            cb(this.canvas, {\r\n                                type: CanvasContext['2D'],\r\n                                property: prop,\r\n                                args: recordArgs,\r\n                            });\r\n                        }, 0);\r\n                    }\r\n                    return original.apply(this, args);\r\n                };\r\n            });\r\n            handlers.push(restoreHandler);\r\n        }\r\n        catch {\r\n            const hookHandler = hookSetter(win.CanvasRenderingContext2D.prototype, prop, {\r\n                set(v) {\r\n                    cb(this.canvas, {\r\n                        type: CanvasContext['2D'],\r\n                        property: prop,\r\n                        args: [v],\r\n                        setter: true,\r\n                    });\r\n                },\r\n            });\r\n            handlers.push(hookHandler);\r\n        }\r\n    }\r\n    return () => {\r\n        handlers.forEach((h) => h());\r\n    };\r\n}\n\nexport { initCanvas2DMutationObserver as default };\n","import { patch, isBlocked } from '../../../utils.js';\n\nfunction getNormalizedContextName(contextType) {\r\n    return contextType === 'experimental-webgl' ? 'webgl' : contextType;\r\n}\r\nfunction initCanvasContextObserver(win, blockClass, blockSelector, unblockSelector, setPreserveDrawingBufferToTrue) {\r\n    const handlers = [];\r\n    try {\r\n        const restoreHandler = patch(win.HTMLCanvasElement.prototype, 'getContext', function (original) {\r\n            return function (contextType, ...args) {\r\n                if (!isBlocked(this, blockClass, blockSelector, unblockSelector, true)) {\r\n                    const ctxName = getNormalizedContextName(contextType);\r\n                    if (!('__context' in this))\r\n                        this.__context = ctxName;\r\n                    if (setPreserveDrawingBufferToTrue &&\r\n                        ['webgl', 'webgl2'].includes(ctxName)) {\r\n                        if (args[0] && typeof args[0] === 'object') {\r\n                            const contextAttributes = args[0];\r\n                            if (!contextAttributes.preserveDrawingBuffer) {\r\n                                contextAttributes.preserveDrawingBuffer = true;\r\n                            }\r\n                        }\r\n                        else {\r\n                            args.splice(0, 1, {\r\n                                preserveDrawingBuffer: true,\r\n                            });\r\n                        }\r\n                    }\r\n                }\r\n                return original.apply(this, [contextType, ...args]);\r\n            };\r\n        });\r\n        handlers.push(restoreHandler);\r\n    }\r\n    catch {\r\n        console.error('failed to patch HTMLCanvasElement.prototype.getContext');\r\n    }\r\n    return () => {\r\n        handlers.forEach((h) => h());\r\n    };\r\n}\n\nexport { initCanvasContextObserver as default };\n","import { CanvasContext } from '../../../../../types/dist/rrweb-types.js';\nimport { patch, isBlocked, hookSetter } from '../../../utils.js';\nimport { saveWebGLVar, serializeArgs } from './serialize-args.js';\n\nfunction patchGLPrototype(prototype, type, cb, blockClass, blockSelector, unblockSelector, mirror, win) {\r\n    const handlers = [];\r\n    const props = Object.getOwnPropertyNames(prototype);\r\n    for (const prop of props) {\r\n        if ([\r\n            'isContextLost',\r\n            'canvas',\r\n            'drawingBufferWidth',\r\n            'drawingBufferHeight',\r\n        ].includes(prop)) {\r\n            continue;\r\n        }\r\n        try {\r\n            if (typeof prototype[prop] !== 'function') {\r\n                continue;\r\n            }\r\n            const restoreHandler = patch(prototype, prop, function (original) {\r\n                return function (...args) {\r\n                    const result = original.apply(this, args);\r\n                    saveWebGLVar(result, win, this);\r\n                    if ('tagName' in this.canvas &&\r\n                        !isBlocked(this.canvas, blockClass, blockSelector, unblockSelector, true)) {\r\n                        const recordArgs = serializeArgs(args, win, this);\r\n                        const mutation = {\r\n                            type,\r\n                            property: prop,\r\n                            args: recordArgs,\r\n                        };\r\n                        cb(this.canvas, mutation);\r\n                    }\r\n                    return result;\r\n                };\r\n            });\r\n            handlers.push(restoreHandler);\r\n        }\r\n        catch {\r\n            const hookHandler = hookSetter(prototype, prop, {\r\n                set(v) {\r\n                    cb(this.canvas, {\r\n                        type,\r\n                        property: prop,\r\n                        args: [v],\r\n                        setter: true,\r\n                    });\r\n                },\r\n            });\r\n            handlers.push(hookHandler);\r\n        }\r\n    }\r\n    return handlers;\r\n}\r\nfunction initCanvasWebGLMutationObserver(cb, win, blockClass, blockSelector, unblockSelector, mirror) {\r\n    const handlers = [];\r\n    handlers.push(...patchGLPrototype(win.WebGLRenderingContext.prototype, CanvasContext.WebGL, cb, blockClass, blockSelector, unblockSelector, mirror, win));\r\n    if (typeof win.WebGL2RenderingContext !== 'undefined') {\r\n        handlers.push(...patchGLPrototype(win.WebGL2RenderingContext.prototype, CanvasContext.WebGL2, cb, blockClass, blockSelector, unblockSelector, mirror, win));\r\n    }\r\n    return () => {\r\n        handlers.forEach((h) => h());\r\n    };\r\n}\n\nexport { initCanvasWebGLMutationObserver as default };\n","var r = `for(var e=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\",t=\"undefined\"==typeof Uint8Array?[]:new Uint8Array(256),a=0;a<64;a++)t[e.charCodeAt(a)]=a;var n=function(t){var a,n=new Uint8Array(t),r=n.length,s=\"\";for(a=0;a<r;a+=3)s+=e[n[a]>>2],s+=e[(3&n[a])<<4|n[a+1]>>4],s+=e[(15&n[a+1])<<2|n[a+2]>>6],s+=e[63&n[a+2]];return r%3==2?s=s.substring(0,s.length-1)+\"=\":r%3==1&&(s=s.substring(0,s.length-2)+\"==\"),s};const r=new Map,s=new Map;const i=self;i.onmessage=async function(e){if(!(\"OffscreenCanvas\"in globalThis))return i.postMessage({id:e.data.id});{const{id:t,bitmap:a,width:o,height:f,maxCanvasSize:c,dataURLOptions:g}=e.data,u=async function(e,t,a){const r=e+\"-\"+t;if(\"OffscreenCanvas\"in globalThis){if(s.has(r))return s.get(r);const i=new OffscreenCanvas(e,t);i.getContext(\"2d\");const o=await i.convertToBlob(a),f=await o.arrayBuffer(),c=n(f);return s.set(r,c),c}return\"\"}(o,f,g),[h,d]=function(e,t,a){if(!a)return[e,t];const[n,r]=a;if(e<=n&&t<=r)return[e,t];let s=e,i=t;return s>n&&(i=Math.floor(n*t/e),s=n),i>r&&(s=Math.floor(r*e/t),i=r),[s,i]}(o,f,c),l=new OffscreenCanvas(h,d),w=l.getContext(\"bitmaprenderer\"),p=h===o&&d===f?a:await createImageBitmap(a,{resizeWidth:h,resizeHeight:d,resizeQuality:\"low\"});w.transferFromImageBitmap(p),a.close();const y=await l.convertToBlob(g),v=y.type,b=await y.arrayBuffer(),m=n(b);if(p.close(),!r.has(t)&&await u===m)return r.set(t,m),i.postMessage({id:t});if(r.get(t)===m)return i.postMessage({id:t});i.postMessage({id:t,type:v,base64:m,width:o,height:f}),r.set(t,m)}};`;\n\nexport { r as default };\n","import r from './image-bitmap-data-url-worker.js';\n\nfunction t(){const t=new Blob([r]);return URL.createObjectURL(t)}\n\nexport { t as getImageBitmapDataUrlWorkerURL };\n","import { onRequestAnimationFrame, isBlocked } from '../../../utils.js';\nimport { CanvasContext } from '../../../../../types/dist/rrweb-types.js';\nimport initCanvas2DMutationObserver from './2d.js';\nimport initCanvasContextObserver from './canvas.js';\nimport initCanvasWebGLMutationObserver from './webgl.js';\nimport { getImageBitmapDataUrlWorkerURL as t } from '../../../../../rrweb-worker/es/rrweb-worker/index.js';\nimport { callbackWrapper, registerErrorHandler } from '../../error-handler.js';\n\nclass CanvasManagerNoop {\r\n    reset() {\r\n    }\r\n    freeze() {\r\n    }\r\n    unfreeze() {\r\n    }\r\n    lock() {\r\n    }\r\n    unlock() {\r\n    }\r\n    snapshot() {\r\n    }\r\n    addWindow() {\r\n    }\r\n    addShadowRoot() {\r\n    }\r\n    resetShadowRoots() {\r\n    }\r\n}\r\nclass CanvasManager {\r\n    reset() {\r\n        this.pendingCanvasMutations.clear();\r\n        this.restoreHandlers.forEach((handler) => {\r\n            try {\r\n                handler();\r\n            }\r\n            catch (e) {\r\n            }\r\n        });\r\n        this.restoreHandlers = [];\r\n        this.windowsSet = new WeakSet();\r\n        this.windows = [];\r\n        this.shadowDoms = new Set();\r\n        this.worker?.terminate();\r\n        this.worker = null;\r\n        this.snapshotInProgressMap = new Map();\r\n    }\r\n    freeze() {\r\n        this.frozen = true;\r\n    }\r\n    unfreeze() {\r\n        this.frozen = false;\r\n    }\r\n    lock() {\r\n        this.locked = true;\r\n    }\r\n    unlock() {\r\n        this.locked = false;\r\n    }\r\n    constructor(options) {\r\n        this.pendingCanvasMutations = new Map();\r\n        this.rafStamps = { latestId: 0, invokeId: null };\r\n        this.shadowDoms = new Set();\r\n        this.windowsSet = new WeakSet();\r\n        this.windows = [];\r\n        this.restoreHandlers = [];\r\n        this.frozen = false;\r\n        this.locked = false;\r\n        this.snapshotInProgressMap = new Map();\r\n        this.worker = null;\r\n        this.processMutation = (target, mutation) => {\r\n            const newFrame = this.rafStamps.invokeId &&\r\n                this.rafStamps.latestId !== this.rafStamps.invokeId;\r\n            if (newFrame || !this.rafStamps.invokeId)\r\n                this.rafStamps.invokeId = this.rafStamps.latestId;\r\n            if (!this.pendingCanvasMutations.has(target)) {\r\n                this.pendingCanvasMutations.set(target, []);\r\n            }\r\n            this.pendingCanvasMutations.get(target).push(mutation);\r\n        };\r\n        const { sampling = 'all', win, blockClass, blockSelector, unblockSelector, maxCanvasSize, recordCanvas, dataURLOptions, errorHandler, } = options;\r\n        this.mutationCb = options.mutationCb;\r\n        this.mirror = options.mirror;\r\n        this.options = options;\r\n        if (errorHandler) {\r\n            registerErrorHandler(errorHandler);\r\n        }\r\n        if ((recordCanvas && typeof sampling === 'number') ||\r\n            options.enableManualSnapshot) {\r\n            this.worker = this.initFPSWorker();\r\n        }\r\n        this.addWindow(win);\r\n        if (options.enableManualSnapshot) {\r\n            return;\r\n        }\r\n        callbackWrapper(() => {\r\n            if (recordCanvas && sampling === 'all') {\r\n                this.startRAFTimestamping();\r\n                this.startPendingCanvasMutationFlusher();\r\n            }\r\n            if (recordCanvas && typeof sampling === 'number') {\r\n                this.initCanvasFPSObserver(sampling, blockClass, blockSelector, unblockSelector, maxCanvasSize, {\r\n                    dataURLOptions,\r\n                });\r\n            }\r\n        })();\r\n    }\r\n    addWindow(win) {\r\n        const { sampling = 'all', blockClass, blockSelector, unblockSelector, recordCanvas, enableManualSnapshot, } = this.options;\r\n        if (this.windowsSet.has(win))\r\n            return;\r\n        if (enableManualSnapshot) {\r\n            this.windowsSet.add(win);\r\n            this.windows.push(new WeakRef(win));\r\n            return;\r\n        }\r\n        callbackWrapper(() => {\r\n            if (recordCanvas && sampling === 'all') {\r\n                this.initCanvasMutationObserver(win, blockClass, blockSelector, unblockSelector);\r\n            }\r\n            if (recordCanvas && typeof sampling === 'number') {\r\n                const canvasContextReset = initCanvasContextObserver(win, blockClass, blockSelector, unblockSelector, true);\r\n                this.restoreHandlers.push(() => {\r\n                    canvasContextReset();\r\n                });\r\n            }\r\n        })();\r\n        this.windowsSet.add(win);\r\n        this.windows.push(new WeakRef(win));\r\n    }\r\n    addShadowRoot(shadowRoot) {\r\n        this.shadowDoms.add(new WeakRef(shadowRoot));\r\n    }\r\n    resetShadowRoots() {\r\n        this.shadowDoms = new Set();\r\n    }\r\n    initFPSWorker() {\r\n        const worker = new Worker(t());\r\n        worker.onmessage = (e) => {\r\n            const data = e.data;\r\n            const { id } = data;\r\n            this.snapshotInProgressMap.set(id, false);\r\n            if (!('base64' in data))\r\n                return;\r\n            const { base64, type, width, height } = data;\r\n            this.mutationCb({\r\n                id,\r\n                type: CanvasContext['2D'],\r\n                commands: [\r\n                    {\r\n                        property: 'clearRect',\r\n                        args: [0, 0, width, height],\r\n                    },\r\n                    {\r\n                        property: 'drawImage',\r\n                        args: [\r\n                            {\r\n                                rr_type: 'ImageBitmap',\r\n                                args: [\r\n                                    {\r\n                                        rr_type: 'Blob',\r\n                                        data: [{ rr_type: 'ArrayBuffer', base64 }],\r\n                                        type,\r\n                                    },\r\n                                ],\r\n                            },\r\n                            0,\r\n                            0,\r\n                            width,\r\n                            height,\r\n                        ],\r\n                    },\r\n                ],\r\n            });\r\n        };\r\n        return worker;\r\n    }\r\n    initCanvasFPSObserver(fps, blockClass, blockSelector, unblockSelector, maxCanvasSize, options) {\r\n        const rafId = this.takeSnapshot(false, fps, blockClass, blockSelector, unblockSelector, maxCanvasSize, options.dataURLOptions);\r\n        this.restoreHandlers.push(() => {\r\n            cancelAnimationFrame(rafId);\r\n        });\r\n    }\r\n    initCanvasMutationObserver(win, blockClass, blockSelector, unblockSelector) {\r\n        const canvasContextReset = initCanvasContextObserver(win, blockClass, blockSelector, unblockSelector, false);\r\n        const canvas2DReset = initCanvas2DMutationObserver(this.processMutation.bind(this), win, blockClass, blockSelector, unblockSelector);\r\n        const canvasWebGL1and2Reset = initCanvasWebGLMutationObserver(this.processMutation.bind(this), win, blockClass, blockSelector, unblockSelector, this.mirror);\r\n        this.restoreHandlers.push(() => {\r\n            canvasContextReset();\r\n            canvas2DReset();\r\n            canvasWebGL1and2Reset();\r\n        });\r\n    }\r\n    snapshot(canvasElement) {\r\n        const { options } = this;\r\n        const rafId = this.takeSnapshot(true, options.sampling === 'all' ? 2 : options.sampling || 2, options.blockClass, options.blockSelector, options.unblockSelector, options.maxCanvasSize, options.dataURLOptions, canvasElement);\r\n        this.restoreHandlers.push(() => {\r\n            cancelAnimationFrame(rafId);\r\n        });\r\n    }\r\n    takeSnapshot(isManualSnapshot, fps, blockClass, blockSelector, unblockSelector, maxCanvasSize, dataURLOptions, canvasElement) {\r\n        const timeBetweenSnapshots = 1000 / fps;\r\n        let lastSnapshotTime = 0;\r\n        let rafId;\r\n        const getCanvas = (canvasElement) => {\r\n            if (canvasElement) {\r\n                return [canvasElement];\r\n            }\r\n            const matchedCanvas = [];\r\n            const searchCanvas = (root) => {\r\n                root.querySelectorAll('canvas').forEach((canvas) => {\r\n                    if (!isBlocked(canvas, blockClass, blockSelector, unblockSelector, true)) {\r\n                        matchedCanvas.push(canvas);\r\n                    }\r\n                });\r\n            };\r\n            for (const item of this.windows) {\r\n                const window = item.deref();\r\n                if (window) {\r\n                    searchCanvas(window.document);\r\n                }\r\n            }\r\n            for (const item of this.shadowDoms) {\r\n                const shadowRoot = item.deref();\r\n                if (shadowRoot) {\r\n                    searchCanvas(shadowRoot);\r\n                }\r\n            }\r\n            return matchedCanvas;\r\n        };\r\n        const takeCanvasSnapshots = (timestamp) => {\r\n            if (!this.windows.length) {\r\n                return;\r\n            }\r\n            if (lastSnapshotTime &&\r\n                timestamp - lastSnapshotTime < timeBetweenSnapshots) {\r\n                rafId = onRequestAnimationFrame(takeCanvasSnapshots);\r\n                return;\r\n            }\r\n            lastSnapshotTime = timestamp;\r\n            getCanvas(canvasElement).forEach((canvas) => {\r\n                if (!this.mirror.hasNode(canvas)) {\r\n                    return;\r\n                }\r\n                const id = this.mirror.getId(canvas);\r\n                if (this.snapshotInProgressMap.get(id))\r\n                    return;\r\n                if (!canvas.width || !canvas.height)\r\n                    return;\r\n                this.snapshotInProgressMap.set(id, true);\r\n                if (!isManualSnapshot &&\r\n                    ['webgl', 'webgl2'].includes(canvas.__context)) {\r\n                    const context = canvas.getContext(canvas.__context);\r\n                    if (context?.getContextAttributes()?.preserveDrawingBuffer === false) {\r\n                        context.clear(context.COLOR_BUFFER_BIT);\r\n                    }\r\n                }\r\n                createImageBitmap(canvas)\r\n                    .then((bitmap) => {\r\n                    this.worker?.postMessage({\r\n                        id,\r\n                        bitmap,\r\n                        width: canvas.width,\r\n                        height: canvas.height,\r\n                        dataURLOptions,\r\n                        maxCanvasSize,\r\n                    }, [bitmap]);\r\n                })\r\n                    .catch((error) => {\r\n                    callbackWrapper(() => {\r\n                        throw error;\r\n                    })();\r\n                });\r\n            });\r\n            if (!isManualSnapshot) {\r\n                rafId = onRequestAnimationFrame(takeCanvasSnapshots);\r\n            }\r\n        };\r\n        rafId = onRequestAnimationFrame(takeCanvasSnapshots);\r\n        return rafId;\r\n    }\r\n    startPendingCanvasMutationFlusher() {\r\n        onRequestAnimationFrame(() => this.flushPendingCanvasMutations());\r\n    }\r\n    startRAFTimestamping() {\r\n        const setLatestRAFTimestamp = (timestamp) => {\r\n            this.rafStamps.latestId = timestamp;\r\n            onRequestAnimationFrame(setLatestRAFTimestamp);\r\n        };\r\n        onRequestAnimationFrame(setLatestRAFTimestamp);\r\n    }\r\n    flushPendingCanvasMutations() {\r\n        this.pendingCanvasMutations.forEach((values, canvas) => {\r\n            const id = this.mirror.getId(canvas);\r\n            this.flushPendingCanvasMutationFor(canvas, id);\r\n        });\r\n        onRequestAnimationFrame(() => this.flushPendingCanvasMutations());\r\n    }\r\n    flushPendingCanvasMutationFor(canvas, id) {\r\n        if (this.frozen || this.locked) {\r\n            return;\r\n        }\r\n        const valuesWithType = this.pendingCanvasMutations.get(canvas);\r\n        if (!valuesWithType || id === -1)\r\n            return;\r\n        const values = valuesWithType.map((value) => {\r\n            const { type, ...rest } = value;\r\n            return rest;\r\n        });\r\n        const { type } = valuesWithType[0];\r\n        this.mutationCb({ id, type, commands: values });\r\n        this.pendingCanvasMutations.delete(canvas);\r\n    }\r\n}\n\nexport { CanvasManager, CanvasManagerNoop };\n","import type { CanvasManagerInterface, CanvasManagerOptions } from '@sentry-internal/replay';\nimport { CanvasManager } from '@sentry-internal/rrweb';\nimport { defineIntegration } from '@sentry/core';\nimport type { Integration, IntegrationFn } from '@sentry/core';\n\ninterface ReplayCanvasIntegration extends Integration {\n  snapshot: (canvasElement?: HTMLCanvasElement) => Promise<void>;\n}\n\ninterface ReplayCanvasOptions {\n  enableManualSnapshot?: boolean;\n  maxCanvasSize?: [width: number, height: number];\n  quality: 'low' | 'medium' | 'high';\n}\n\ntype GetCanvasManager = (options: CanvasManagerOptions) => CanvasManagerInterface;\nexport interface ReplayCanvasIntegrationOptions {\n  enableManualSnapshot?: boolean;\n  maxCanvasSize?: number;\n  recordCanvas: true;\n  getCanvasManager: GetCanvasManager;\n  sampling: {\n    canvas: number;\n  };\n  dataURLOptions: {\n    type: string;\n    quality: number;\n  };\n}\n\nconst CANVAS_QUALITY = {\n  low: {\n    sampling: {\n      canvas: 1,\n    },\n    dataURLOptions: {\n      type: 'image/webp',\n      quality: 0.25,\n    },\n  },\n  medium: {\n    sampling: {\n      canvas: 2,\n    },\n    dataURLOptions: {\n      type: 'image/webp',\n      quality: 0.4,\n    },\n  },\n  high: {\n    sampling: {\n      canvas: 4,\n    },\n    dataURLOptions: {\n      type: 'image/webp',\n      quality: 0.5,\n    },\n  },\n};\n\nconst INTEGRATION_NAME = 'ReplayCanvas';\nconst DEFAULT_MAX_CANVAS_SIZE = 1280;\n\n/** Exported only for type safe tests. */\nexport const _replayCanvasIntegration = ((options: Partial<ReplayCanvasOptions> = {}) => {\n  const [maxCanvasWidth, maxCanvasHeight] = options.maxCanvasSize || [];\n  const _canvasOptions = {\n    quality: options.quality || 'medium',\n    enableManualSnapshot: options.enableManualSnapshot,\n    maxCanvasSize: [\n      maxCanvasWidth ? Math.min(maxCanvasWidth, DEFAULT_MAX_CANVAS_SIZE) : DEFAULT_MAX_CANVAS_SIZE,\n      maxCanvasHeight ? Math.min(maxCanvasHeight, DEFAULT_MAX_CANVAS_SIZE) : DEFAULT_MAX_CANVAS_SIZE,\n    ] as [number, number],\n  };\n\n  let canvasManagerResolve: (value: CanvasManager) => void;\n  const _canvasManager: Promise<CanvasManager> = new Promise(resolve => (canvasManagerResolve = resolve));\n\n  return {\n    name: INTEGRATION_NAME,\n    getOptions(): ReplayCanvasIntegrationOptions {\n      const { quality, enableManualSnapshot, maxCanvasSize } = _canvasOptions;\n\n      return {\n        enableManualSnapshot,\n        recordCanvas: true,\n        getCanvasManager: (getCanvasManagerOptions: CanvasManagerOptions) => {\n          const manager = new CanvasManager({\n            ...getCanvasManagerOptions,\n            enableManualSnapshot,\n            maxCanvasSize,\n            errorHandler: (err: unknown) => {\n              try {\n                if (typeof err === 'object') {\n                  (err as Error & { __rrweb__?: boolean }).__rrweb__ = true;\n                }\n              } catch (error) {\n                // ignore errors here\n                // this can happen if the error is frozen or does not allow mutation for other reasons\n              }\n            },\n          });\n          canvasManagerResolve(manager);\n          return manager;\n        },\n        ...(CANVAS_QUALITY[quality || 'medium'] || CANVAS_QUALITY.medium),\n      };\n    },\n    async snapshot(canvasElement?: HTMLCanvasElement) {\n      const canvasManager = await _canvasManager;\n      canvasManager.snapshot(canvasElement);\n    },\n  };\n}) satisfies IntegrationFn<ReplayCanvasIntegration>;\n\n/**\n * Add this in addition to `replayIntegration()` to enable canvas recording.\n */\nexport const replayCanvasIntegration = defineIntegration(\n  _replayCanvasIntegration,\n) as IntegrationFn<ReplayCanvasIntegration>;\n"],"names":["defineIntegration"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11]}