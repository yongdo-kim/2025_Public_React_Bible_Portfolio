{"version":3,"file":"history.js","sources":["../../../src/instrument/history.ts"],"sourcesContent":["import type { HandlerDataHistory } from '@sentry/core';\nimport { addHandler, fill, maybeInstrument, supportsHistory, triggerHandlers } from '@sentry/core';\nimport { WINDOW } from '../types';\n\nlet lastHref: string | undefined;\n\n/**\n * Add an instrumentation handler for when a fetch request happens.\n * The handler function is called once when the request starts and once when it ends,\n * which can be identified by checking if it has an `endTimestamp`.\n *\n * Use at your own risk, this might break without changelog notice, only used internally.\n * @hidden\n */\nexport function addHistoryInstrumentationHandler(handler: (data: HandlerDataHistory) => void): void {\n  const type = 'history';\n  addHandler(type, handler);\n  maybeInstrument(type, instrumentHistory);\n}\n\nfunction instrumentHistory(): void {\n  // The `popstate` event may also be triggered on `pushState`, but it may not always reliably be emitted by the browser\n  // Which is why we also monkey-patch methods below, in addition to this\n  WINDOW.addEventListener('popstate', () => {\n    const to = WINDOW.location.href;\n    // keep track of the current URL state, as we always receive only the updated state\n    const from = lastHref;\n    lastHref = to;\n\n    if (from === to) {\n      return;\n    }\n\n    const handlerData = { from, to } satisfies HandlerDataHistory;\n    triggerHandlers('history', handlerData);\n  });\n\n  // Just guard against this not being available, in weird environments\n  if (!supportsHistory()) {\n    return;\n  }\n\n  function historyReplacementFunction(originalHistoryFunction: () => void): () => void {\n    return function (this: History, ...args: unknown[]): void {\n      const url = args.length > 2 ? args[2] : undefined;\n      if (url) {\n        // coerce to string (this is what pushState does)\n        const from = lastHref;\n        const to = String(url);\n        // keep track of the current URL state, as we always receive only the updated state\n        lastHref = to;\n\n        if (from === to) {\n          return;\n        }\n\n        const handlerData = { from, to } satisfies HandlerDataHistory;\n        triggerHandlers('history', handlerData);\n      }\n      return originalHistoryFunction.apply(this, args);\n    };\n  }\n\n  fill(WINDOW.history, 'pushState', historyReplacementFunction);\n  fill(WINDOW.history, 'replaceState', historyReplacementFunction);\n}\n"],"names":[],"mappings":";;;AAIA,IAAI,QAAQ;;AAEZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAAS,gCAAgC,CAAC,OAAO,EAA4C;AACpG,EAAE,MAAM,IAAK,GAAE,SAAS;AACxB,EAAE,UAAU,CAAC,IAAI,EAAE,OAAO,CAAC;AAC3B,EAAE,eAAe,CAAC,IAAI,EAAE,iBAAiB,CAAC;AAC1C;;AAEA,SAAS,iBAAiB,GAAS;AACnC;AACA;AACA,EAAE,MAAM,CAAC,gBAAgB,CAAC,UAAU,EAAE,MAAM;AAC5C,IAAI,MAAM,EAAG,GAAE,MAAM,CAAC,QAAQ,CAAC,IAAI;AACnC;AACA,IAAI,MAAM,IAAK,GAAE,QAAQ;AACzB,IAAI,QAAA,GAAW,EAAE;;AAEjB,IAAI,IAAI,IAAK,KAAI,EAAE,EAAE;AACrB,MAAM;AACN;;AAEA,IAAI,MAAM,WAAY,GAAE,EAAE,IAAI,EAAE,IAAK;AACrC,IAAI,eAAe,CAAC,SAAS,EAAE,WAAW,CAAC;AAC3C,GAAG,CAAC;;AAEJ;AACA,EAAE,IAAI,CAAC,eAAe,EAAE,EAAE;AAC1B,IAAI;AACJ;;AAEA,EAAE,SAAS,0BAA0B,CAAC,uBAAuB,EAA0B;AACvF,IAAI,OAAO,WAAyB,GAAG,IAAI,EAAmB;AAC9D,MAAM,MAAM,GAAA,GAAM,IAAI,CAAC,MAAO,GAAE,CAAE,GAAE,IAAI,CAAC,CAAC,CAAA,GAAI,SAAS;AACvD,MAAM,IAAI,GAAG,EAAE;AACf;AACA,QAAQ,MAAM,IAAK,GAAE,QAAQ;AAC7B,QAAQ,MAAM,EAAG,GAAE,MAAM,CAAC,GAAG,CAAC;AAC9B;AACA,QAAQ,QAAA,GAAW,EAAE;;AAErB,QAAQ,IAAI,IAAK,KAAI,EAAE,EAAE;AACzB,UAAU;AACV;;AAEA,QAAQ,MAAM,WAAY,GAAE,EAAE,IAAI,EAAE,IAAK;AACzC,QAAQ,eAAe,CAAC,SAAS,EAAE,WAAW,CAAC;AAC/C;AACA,MAAM,OAAO,uBAAuB,CAAC,KAAK,CAAC,IAAI,EAAE,IAAI,CAAC;AACtD,KAAK;AACL;;AAEA,EAAE,IAAI,CAAC,MAAM,CAAC,OAAO,EAAE,WAAW,EAAE,0BAA0B,CAAC;AAC/D,EAAE,IAAI,CAAC,MAAM,CAAC,OAAO,EAAE,cAAc,EAAE,0BAA0B,CAAC;AAClE;;;;"}