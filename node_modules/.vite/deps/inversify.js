import {
  __privateAdd,
  __privateGet,
  __privateSet,
  __publicField
} from "./chunk-WOOG5QLI.js";

// node_modules/reflect-metadata/Reflect.js
var Reflect2;
(function(Reflect3) {
  (function(factory) {
    var root = typeof globalThis === "object" ? globalThis : typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : sloppyModeThis();
    var exporter = makeExporter(Reflect3);
    if (typeof root.Reflect !== "undefined") {
      exporter = makeExporter(root.Reflect, exporter);
    }
    factory(exporter, root);
    if (typeof root.Reflect === "undefined") {
      root.Reflect = Reflect3;
    }
    function makeExporter(target, previous) {
      return function(key, value) {
        Object.defineProperty(target, key, { configurable: true, writable: true, value });
        if (previous)
          previous(key, value);
      };
    }
    function functionThis() {
      try {
        return Function("return this;")();
      } catch (_3) {
      }
    }
    function indirectEvalThis() {
      try {
        return (void 0, eval)("(function() { return this; })()");
      } catch (_3) {
      }
    }
    function sloppyModeThis() {
      return functionThis() || indirectEvalThis();
    }
  })(function(exporter, root) {
    var hasOwn = Object.prototype.hasOwnProperty;
    var supportsSymbol = typeof Symbol === "function";
    var toPrimitiveSymbol = supportsSymbol && typeof Symbol.toPrimitive !== "undefined" ? Symbol.toPrimitive : "@@toPrimitive";
    var iteratorSymbol = supportsSymbol && typeof Symbol.iterator !== "undefined" ? Symbol.iterator : "@@iterator";
    var supportsCreate = typeof Object.create === "function";
    var supportsProto = { __proto__: [] } instanceof Array;
    var downLevel = !supportsCreate && !supportsProto;
    var HashMap = {
      // create an object in dictionary mode (a.k.a. "slow" mode in v8)
      create: supportsCreate ? function() {
        return MakeDictionary(/* @__PURE__ */ Object.create(null));
      } : supportsProto ? function() {
        return MakeDictionary({ __proto__: null });
      } : function() {
        return MakeDictionary({});
      },
      has: downLevel ? function(map, key) {
        return hasOwn.call(map, key);
      } : function(map, key) {
        return key in map;
      },
      get: downLevel ? function(map, key) {
        return hasOwn.call(map, key) ? map[key] : void 0;
      } : function(map, key) {
        return map[key];
      }
    };
    var functionPrototype = Object.getPrototypeOf(Function);
    var _Map = typeof Map === "function" && typeof Map.prototype.entries === "function" ? Map : CreateMapPolyfill();
    var _Set = typeof Set === "function" && typeof Set.prototype.entries === "function" ? Set : CreateSetPolyfill();
    var _WeakMap = typeof WeakMap === "function" ? WeakMap : CreateWeakMapPolyfill();
    var registrySymbol = supportsSymbol ? Symbol.for("@reflect-metadata:registry") : void 0;
    var metadataRegistry = GetOrCreateMetadataRegistry();
    var metadataProvider = CreateMetadataProvider(metadataRegistry);
    function decorate(decorators, target, propertyKey, attributes) {
      if (!IsUndefined(propertyKey)) {
        if (!IsArray(decorators))
          throw new TypeError();
        if (!IsObject(target))
          throw new TypeError();
        if (!IsObject(attributes) && !IsUndefined(attributes) && !IsNull(attributes))
          throw new TypeError();
        if (IsNull(attributes))
          attributes = void 0;
        propertyKey = ToPropertyKey(propertyKey);
        return DecorateProperty(decorators, target, propertyKey, attributes);
      } else {
        if (!IsArray(decorators))
          throw new TypeError();
        if (!IsConstructor(target))
          throw new TypeError();
        return DecorateConstructor(decorators, target);
      }
    }
    exporter("decorate", decorate);
    function metadata(metadataKey, metadataValue) {
      function decorator(target, propertyKey) {
        if (!IsObject(target))
          throw new TypeError();
        if (!IsUndefined(propertyKey) && !IsPropertyKey(propertyKey))
          throw new TypeError();
        OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
      }
      return decorator;
    }
    exporter("metadata", metadata);
    function defineMetadata(metadataKey, metadataValue, target, propertyKey) {
      if (!IsObject(target))
        throw new TypeError();
      if (!IsUndefined(propertyKey))
        propertyKey = ToPropertyKey(propertyKey);
      return OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
    }
    exporter("defineMetadata", defineMetadata);
    function hasMetadata(metadataKey, target, propertyKey) {
      if (!IsObject(target))
        throw new TypeError();
      if (!IsUndefined(propertyKey))
        propertyKey = ToPropertyKey(propertyKey);
      return OrdinaryHasMetadata(metadataKey, target, propertyKey);
    }
    exporter("hasMetadata", hasMetadata);
    function hasOwnMetadata(metadataKey, target, propertyKey) {
      if (!IsObject(target))
        throw new TypeError();
      if (!IsUndefined(propertyKey))
        propertyKey = ToPropertyKey(propertyKey);
      return OrdinaryHasOwnMetadata(metadataKey, target, propertyKey);
    }
    exporter("hasOwnMetadata", hasOwnMetadata);
    function getMetadata(metadataKey, target, propertyKey) {
      if (!IsObject(target))
        throw new TypeError();
      if (!IsUndefined(propertyKey))
        propertyKey = ToPropertyKey(propertyKey);
      return OrdinaryGetMetadata(metadataKey, target, propertyKey);
    }
    exporter("getMetadata", getMetadata);
    function getOwnMetadata(metadataKey, target, propertyKey) {
      if (!IsObject(target))
        throw new TypeError();
      if (!IsUndefined(propertyKey))
        propertyKey = ToPropertyKey(propertyKey);
      return OrdinaryGetOwnMetadata(metadataKey, target, propertyKey);
    }
    exporter("getOwnMetadata", getOwnMetadata);
    function getMetadataKeys(target, propertyKey) {
      if (!IsObject(target))
        throw new TypeError();
      if (!IsUndefined(propertyKey))
        propertyKey = ToPropertyKey(propertyKey);
      return OrdinaryMetadataKeys(target, propertyKey);
    }
    exporter("getMetadataKeys", getMetadataKeys);
    function getOwnMetadataKeys(target, propertyKey) {
      if (!IsObject(target))
        throw new TypeError();
      if (!IsUndefined(propertyKey))
        propertyKey = ToPropertyKey(propertyKey);
      return OrdinaryOwnMetadataKeys(target, propertyKey);
    }
    exporter("getOwnMetadataKeys", getOwnMetadataKeys);
    function deleteMetadata(metadataKey, target, propertyKey) {
      if (!IsObject(target))
        throw new TypeError();
      if (!IsUndefined(propertyKey))
        propertyKey = ToPropertyKey(propertyKey);
      if (!IsObject(target))
        throw new TypeError();
      if (!IsUndefined(propertyKey))
        propertyKey = ToPropertyKey(propertyKey);
      var provider = GetMetadataProvider(
        target,
        propertyKey,
        /*Create*/
        false
      );
      if (IsUndefined(provider))
        return false;
      return provider.OrdinaryDeleteMetadata(metadataKey, target, propertyKey);
    }
    exporter("deleteMetadata", deleteMetadata);
    function DecorateConstructor(decorators, target) {
      for (var i2 = decorators.length - 1; i2 >= 0; --i2) {
        var decorator = decorators[i2];
        var decorated = decorator(target);
        if (!IsUndefined(decorated) && !IsNull(decorated)) {
          if (!IsConstructor(decorated))
            throw new TypeError();
          target = decorated;
        }
      }
      return target;
    }
    function DecorateProperty(decorators, target, propertyKey, descriptor) {
      for (var i2 = decorators.length - 1; i2 >= 0; --i2) {
        var decorator = decorators[i2];
        var decorated = decorator(target, propertyKey, descriptor);
        if (!IsUndefined(decorated) && !IsNull(decorated)) {
          if (!IsObject(decorated))
            throw new TypeError();
          descriptor = decorated;
        }
      }
      return descriptor;
    }
    function OrdinaryHasMetadata(MetadataKey, O3, P2) {
      var hasOwn2 = OrdinaryHasOwnMetadata(MetadataKey, O3, P2);
      if (hasOwn2)
        return true;
      var parent = OrdinaryGetPrototypeOf(O3);
      if (!IsNull(parent))
        return OrdinaryHasMetadata(MetadataKey, parent, P2);
      return false;
    }
    function OrdinaryHasOwnMetadata(MetadataKey, O3, P2) {
      var provider = GetMetadataProvider(
        O3,
        P2,
        /*Create*/
        false
      );
      if (IsUndefined(provider))
        return false;
      return ToBoolean(provider.OrdinaryHasOwnMetadata(MetadataKey, O3, P2));
    }
    function OrdinaryGetMetadata(MetadataKey, O3, P2) {
      var hasOwn2 = OrdinaryHasOwnMetadata(MetadataKey, O3, P2);
      if (hasOwn2)
        return OrdinaryGetOwnMetadata(MetadataKey, O3, P2);
      var parent = OrdinaryGetPrototypeOf(O3);
      if (!IsNull(parent))
        return OrdinaryGetMetadata(MetadataKey, parent, P2);
      return void 0;
    }
    function OrdinaryGetOwnMetadata(MetadataKey, O3, P2) {
      var provider = GetMetadataProvider(
        O3,
        P2,
        /*Create*/
        false
      );
      if (IsUndefined(provider))
        return;
      return provider.OrdinaryGetOwnMetadata(MetadataKey, O3, P2);
    }
    function OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O3, P2) {
      var provider = GetMetadataProvider(
        O3,
        P2,
        /*Create*/
        true
      );
      provider.OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O3, P2);
    }
    function OrdinaryMetadataKeys(O3, P2) {
      var ownKeys = OrdinaryOwnMetadataKeys(O3, P2);
      var parent = OrdinaryGetPrototypeOf(O3);
      if (parent === null)
        return ownKeys;
      var parentKeys = OrdinaryMetadataKeys(parent, P2);
      if (parentKeys.length <= 0)
        return ownKeys;
      if (ownKeys.length <= 0)
        return parentKeys;
      var set = new _Set();
      var keys = [];
      for (var _i2 = 0, ownKeys_1 = ownKeys; _i2 < ownKeys_1.length; _i2++) {
        var key = ownKeys_1[_i2];
        var hasKey = set.has(key);
        if (!hasKey) {
          set.add(key);
          keys.push(key);
        }
      }
      for (var _a4 = 0, parentKeys_1 = parentKeys; _a4 < parentKeys_1.length; _a4++) {
        var key = parentKeys_1[_a4];
        var hasKey = set.has(key);
        if (!hasKey) {
          set.add(key);
          keys.push(key);
        }
      }
      return keys;
    }
    function OrdinaryOwnMetadataKeys(O3, P2) {
      var provider = GetMetadataProvider(
        O3,
        P2,
        /*create*/
        false
      );
      if (!provider) {
        return [];
      }
      return provider.OrdinaryOwnMetadataKeys(O3, P2);
    }
    function Type(x3) {
      if (x3 === null)
        return 1;
      switch (typeof x3) {
        case "undefined":
          return 0;
        case "boolean":
          return 2;
        case "string":
          return 3;
        case "symbol":
          return 4;
        case "number":
          return 5;
        case "object":
          return x3 === null ? 1 : 6;
        default:
          return 6;
      }
    }
    function IsUndefined(x3) {
      return x3 === void 0;
    }
    function IsNull(x3) {
      return x3 === null;
    }
    function IsSymbol(x3) {
      return typeof x3 === "symbol";
    }
    function IsObject(x3) {
      return typeof x3 === "object" ? x3 !== null : typeof x3 === "function";
    }
    function ToPrimitive(input, PreferredType) {
      switch (Type(input)) {
        case 0:
          return input;
        case 1:
          return input;
        case 2:
          return input;
        case 3:
          return input;
        case 4:
          return input;
        case 5:
          return input;
      }
      var hint = PreferredType === 3 ? "string" : PreferredType === 5 ? "number" : "default";
      var exoticToPrim = GetMethod(input, toPrimitiveSymbol);
      if (exoticToPrim !== void 0) {
        var result = exoticToPrim.call(input, hint);
        if (IsObject(result))
          throw new TypeError();
        return result;
      }
      return OrdinaryToPrimitive(input, hint === "default" ? "number" : hint);
    }
    function OrdinaryToPrimitive(O3, hint) {
      if (hint === "string") {
        var toString_1 = O3.toString;
        if (IsCallable(toString_1)) {
          var result = toString_1.call(O3);
          if (!IsObject(result))
            return result;
        }
        var valueOf = O3.valueOf;
        if (IsCallable(valueOf)) {
          var result = valueOf.call(O3);
          if (!IsObject(result))
            return result;
        }
      } else {
        var valueOf = O3.valueOf;
        if (IsCallable(valueOf)) {
          var result = valueOf.call(O3);
          if (!IsObject(result))
            return result;
        }
        var toString_2 = O3.toString;
        if (IsCallable(toString_2)) {
          var result = toString_2.call(O3);
          if (!IsObject(result))
            return result;
        }
      }
      throw new TypeError();
    }
    function ToBoolean(argument) {
      return !!argument;
    }
    function ToString(argument) {
      return "" + argument;
    }
    function ToPropertyKey(argument) {
      var key = ToPrimitive(
        argument,
        3
        /* String */
      );
      if (IsSymbol(key))
        return key;
      return ToString(key);
    }
    function IsArray(argument) {
      return Array.isArray ? Array.isArray(argument) : argument instanceof Object ? argument instanceof Array : Object.prototype.toString.call(argument) === "[object Array]";
    }
    function IsCallable(argument) {
      return typeof argument === "function";
    }
    function IsConstructor(argument) {
      return typeof argument === "function";
    }
    function IsPropertyKey(argument) {
      switch (Type(argument)) {
        case 3:
          return true;
        case 4:
          return true;
        default:
          return false;
      }
    }
    function SameValueZero(x3, y3) {
      return x3 === y3 || x3 !== x3 && y3 !== y3;
    }
    function GetMethod(V2, P2) {
      var func = V2[P2];
      if (func === void 0 || func === null)
        return void 0;
      if (!IsCallable(func))
        throw new TypeError();
      return func;
    }
    function GetIterator(obj) {
      var method = GetMethod(obj, iteratorSymbol);
      if (!IsCallable(method))
        throw new TypeError();
      var iterator = method.call(obj);
      if (!IsObject(iterator))
        throw new TypeError();
      return iterator;
    }
    function IteratorValue(iterResult) {
      return iterResult.value;
    }
    function IteratorStep(iterator) {
      var result = iterator.next();
      return result.done ? false : result;
    }
    function IteratorClose(iterator) {
      var f3 = iterator["return"];
      if (f3)
        f3.call(iterator);
    }
    function OrdinaryGetPrototypeOf(O3) {
      var proto = Object.getPrototypeOf(O3);
      if (typeof O3 !== "function" || O3 === functionPrototype)
        return proto;
      if (proto !== functionPrototype)
        return proto;
      var prototype = O3.prototype;
      var prototypeProto = prototype && Object.getPrototypeOf(prototype);
      if (prototypeProto == null || prototypeProto === Object.prototype)
        return proto;
      var constructor = prototypeProto.constructor;
      if (typeof constructor !== "function")
        return proto;
      if (constructor === O3)
        return proto;
      return constructor;
    }
    function CreateMetadataRegistry() {
      var fallback;
      if (!IsUndefined(registrySymbol) && typeof root.Reflect !== "undefined" && !(registrySymbol in root.Reflect) && typeof root.Reflect.defineMetadata === "function") {
        fallback = CreateFallbackProvider(root.Reflect);
      }
      var first;
      var second;
      var rest;
      var targetProviderMap = new _WeakMap();
      var registry = {
        registerProvider,
        getProvider,
        setProvider
      };
      return registry;
      function registerProvider(provider) {
        if (!Object.isExtensible(registry)) {
          throw new Error("Cannot add provider to a frozen registry.");
        }
        switch (true) {
          case fallback === provider:
            break;
          case IsUndefined(first):
            first = provider;
            break;
          case first === provider:
            break;
          case IsUndefined(second):
            second = provider;
            break;
          case second === provider:
            break;
          default:
            if (rest === void 0)
              rest = new _Set();
            rest.add(provider);
            break;
        }
      }
      function getProviderNoCache(O3, P2) {
        if (!IsUndefined(first)) {
          if (first.isProviderFor(O3, P2))
            return first;
          if (!IsUndefined(second)) {
            if (second.isProviderFor(O3, P2))
              return first;
            if (!IsUndefined(rest)) {
              var iterator = GetIterator(rest);
              while (true) {
                var next = IteratorStep(iterator);
                if (!next) {
                  return void 0;
                }
                var provider = IteratorValue(next);
                if (provider.isProviderFor(O3, P2)) {
                  IteratorClose(iterator);
                  return provider;
                }
              }
            }
          }
        }
        if (!IsUndefined(fallback) && fallback.isProviderFor(O3, P2)) {
          return fallback;
        }
        return void 0;
      }
      function getProvider(O3, P2) {
        var providerMap = targetProviderMap.get(O3);
        var provider;
        if (!IsUndefined(providerMap)) {
          provider = providerMap.get(P2);
        }
        if (!IsUndefined(provider)) {
          return provider;
        }
        provider = getProviderNoCache(O3, P2);
        if (!IsUndefined(provider)) {
          if (IsUndefined(providerMap)) {
            providerMap = new _Map();
            targetProviderMap.set(O3, providerMap);
          }
          providerMap.set(P2, provider);
        }
        return provider;
      }
      function hasProvider(provider) {
        if (IsUndefined(provider))
          throw new TypeError();
        return first === provider || second === provider || !IsUndefined(rest) && rest.has(provider);
      }
      function setProvider(O3, P2, provider) {
        if (!hasProvider(provider)) {
          throw new Error("Metadata provider not registered.");
        }
        var existingProvider = getProvider(O3, P2);
        if (existingProvider !== provider) {
          if (!IsUndefined(existingProvider)) {
            return false;
          }
          var providerMap = targetProviderMap.get(O3);
          if (IsUndefined(providerMap)) {
            providerMap = new _Map();
            targetProviderMap.set(O3, providerMap);
          }
          providerMap.set(P2, provider);
        }
        return true;
      }
    }
    function GetOrCreateMetadataRegistry() {
      var metadataRegistry2;
      if (!IsUndefined(registrySymbol) && IsObject(root.Reflect) && Object.isExtensible(root.Reflect)) {
        metadataRegistry2 = root.Reflect[registrySymbol];
      }
      if (IsUndefined(metadataRegistry2)) {
        metadataRegistry2 = CreateMetadataRegistry();
      }
      if (!IsUndefined(registrySymbol) && IsObject(root.Reflect) && Object.isExtensible(root.Reflect)) {
        Object.defineProperty(root.Reflect, registrySymbol, {
          enumerable: false,
          configurable: false,
          writable: false,
          value: metadataRegistry2
        });
      }
      return metadataRegistry2;
    }
    function CreateMetadataProvider(registry) {
      var metadata2 = new _WeakMap();
      var provider = {
        isProviderFor: function(O3, P2) {
          var targetMetadata = metadata2.get(O3);
          if (IsUndefined(targetMetadata))
            return false;
          return targetMetadata.has(P2);
        },
        OrdinaryDefineOwnMetadata: OrdinaryDefineOwnMetadata2,
        OrdinaryHasOwnMetadata: OrdinaryHasOwnMetadata2,
        OrdinaryGetOwnMetadata: OrdinaryGetOwnMetadata2,
        OrdinaryOwnMetadataKeys: OrdinaryOwnMetadataKeys2,
        OrdinaryDeleteMetadata
      };
      metadataRegistry.registerProvider(provider);
      return provider;
      function GetOrCreateMetadataMap(O3, P2, Create) {
        var targetMetadata = metadata2.get(O3);
        var createdTargetMetadata = false;
        if (IsUndefined(targetMetadata)) {
          if (!Create)
            return void 0;
          targetMetadata = new _Map();
          metadata2.set(O3, targetMetadata);
          createdTargetMetadata = true;
        }
        var metadataMap = targetMetadata.get(P2);
        if (IsUndefined(metadataMap)) {
          if (!Create)
            return void 0;
          metadataMap = new _Map();
          targetMetadata.set(P2, metadataMap);
          if (!registry.setProvider(O3, P2, provider)) {
            targetMetadata.delete(P2);
            if (createdTargetMetadata) {
              metadata2.delete(O3);
            }
            throw new Error("Wrong provider for target.");
          }
        }
        return metadataMap;
      }
      function OrdinaryHasOwnMetadata2(MetadataKey, O3, P2) {
        var metadataMap = GetOrCreateMetadataMap(
          O3,
          P2,
          /*Create*/
          false
        );
        if (IsUndefined(metadataMap))
          return false;
        return ToBoolean(metadataMap.has(MetadataKey));
      }
      function OrdinaryGetOwnMetadata2(MetadataKey, O3, P2) {
        var metadataMap = GetOrCreateMetadataMap(
          O3,
          P2,
          /*Create*/
          false
        );
        if (IsUndefined(metadataMap))
          return void 0;
        return metadataMap.get(MetadataKey);
      }
      function OrdinaryDefineOwnMetadata2(MetadataKey, MetadataValue, O3, P2) {
        var metadataMap = GetOrCreateMetadataMap(
          O3,
          P2,
          /*Create*/
          true
        );
        metadataMap.set(MetadataKey, MetadataValue);
      }
      function OrdinaryOwnMetadataKeys2(O3, P2) {
        var keys = [];
        var metadataMap = GetOrCreateMetadataMap(
          O3,
          P2,
          /*Create*/
          false
        );
        if (IsUndefined(metadataMap))
          return keys;
        var keysObj = metadataMap.keys();
        var iterator = GetIterator(keysObj);
        var k3 = 0;
        while (true) {
          var next = IteratorStep(iterator);
          if (!next) {
            keys.length = k3;
            return keys;
          }
          var nextValue = IteratorValue(next);
          try {
            keys[k3] = nextValue;
          } catch (e2) {
            try {
              IteratorClose(iterator);
            } finally {
              throw e2;
            }
          }
          k3++;
        }
      }
      function OrdinaryDeleteMetadata(MetadataKey, O3, P2) {
        var metadataMap = GetOrCreateMetadataMap(
          O3,
          P2,
          /*Create*/
          false
        );
        if (IsUndefined(metadataMap))
          return false;
        if (!metadataMap.delete(MetadataKey))
          return false;
        if (metadataMap.size === 0) {
          var targetMetadata = metadata2.get(O3);
          if (!IsUndefined(targetMetadata)) {
            targetMetadata.delete(P2);
            if (targetMetadata.size === 0) {
              metadata2.delete(targetMetadata);
            }
          }
        }
        return true;
      }
    }
    function CreateFallbackProvider(reflect) {
      var defineMetadata2 = reflect.defineMetadata, hasOwnMetadata2 = reflect.hasOwnMetadata, getOwnMetadata2 = reflect.getOwnMetadata, getOwnMetadataKeys2 = reflect.getOwnMetadataKeys, deleteMetadata2 = reflect.deleteMetadata;
      var metadataOwner = new _WeakMap();
      var provider = {
        isProviderFor: function(O3, P2) {
          var metadataPropertySet = metadataOwner.get(O3);
          if (!IsUndefined(metadataPropertySet) && metadataPropertySet.has(P2)) {
            return true;
          }
          if (getOwnMetadataKeys2(O3, P2).length) {
            if (IsUndefined(metadataPropertySet)) {
              metadataPropertySet = new _Set();
              metadataOwner.set(O3, metadataPropertySet);
            }
            metadataPropertySet.add(P2);
            return true;
          }
          return false;
        },
        OrdinaryDefineOwnMetadata: defineMetadata2,
        OrdinaryHasOwnMetadata: hasOwnMetadata2,
        OrdinaryGetOwnMetadata: getOwnMetadata2,
        OrdinaryOwnMetadataKeys: getOwnMetadataKeys2,
        OrdinaryDeleteMetadata: deleteMetadata2
      };
      return provider;
    }
    function GetMetadataProvider(O3, P2, Create) {
      var registeredProvider = metadataRegistry.getProvider(O3, P2);
      if (!IsUndefined(registeredProvider)) {
        return registeredProvider;
      }
      if (Create) {
        if (metadataRegistry.setProvider(O3, P2, metadataProvider)) {
          return metadataProvider;
        }
        throw new Error("Illegal state.");
      }
      return void 0;
    }
    function CreateMapPolyfill() {
      var cacheSentinel = {};
      var arraySentinel = [];
      var MapIterator = (
        /** @class */
        function() {
          function MapIterator2(keys, values, selector) {
            this._index = 0;
            this._keys = keys;
            this._values = values;
            this._selector = selector;
          }
          MapIterator2.prototype["@@iterator"] = function() {
            return this;
          };
          MapIterator2.prototype[iteratorSymbol] = function() {
            return this;
          };
          MapIterator2.prototype.next = function() {
            var index = this._index;
            if (index >= 0 && index < this._keys.length) {
              var result = this._selector(this._keys[index], this._values[index]);
              if (index + 1 >= this._keys.length) {
                this._index = -1;
                this._keys = arraySentinel;
                this._values = arraySentinel;
              } else {
                this._index++;
              }
              return { value: result, done: false };
            }
            return { value: void 0, done: true };
          };
          MapIterator2.prototype.throw = function(error) {
            if (this._index >= 0) {
              this._index = -1;
              this._keys = arraySentinel;
              this._values = arraySentinel;
            }
            throw error;
          };
          MapIterator2.prototype.return = function(value) {
            if (this._index >= 0) {
              this._index = -1;
              this._keys = arraySentinel;
              this._values = arraySentinel;
            }
            return { value, done: true };
          };
          return MapIterator2;
        }()
      );
      var Map2 = (
        /** @class */
        function() {
          function Map3() {
            this._keys = [];
            this._values = [];
            this._cacheKey = cacheSentinel;
            this._cacheIndex = -2;
          }
          Object.defineProperty(Map3.prototype, "size", {
            get: function() {
              return this._keys.length;
            },
            enumerable: true,
            configurable: true
          });
          Map3.prototype.has = function(key) {
            return this._find(
              key,
              /*insert*/
              false
            ) >= 0;
          };
          Map3.prototype.get = function(key) {
            var index = this._find(
              key,
              /*insert*/
              false
            );
            return index >= 0 ? this._values[index] : void 0;
          };
          Map3.prototype.set = function(key, value) {
            var index = this._find(
              key,
              /*insert*/
              true
            );
            this._values[index] = value;
            return this;
          };
          Map3.prototype.delete = function(key) {
            var index = this._find(
              key,
              /*insert*/
              false
            );
            if (index >= 0) {
              var size = this._keys.length;
              for (var i2 = index + 1; i2 < size; i2++) {
                this._keys[i2 - 1] = this._keys[i2];
                this._values[i2 - 1] = this._values[i2];
              }
              this._keys.length--;
              this._values.length--;
              if (SameValueZero(key, this._cacheKey)) {
                this._cacheKey = cacheSentinel;
                this._cacheIndex = -2;
              }
              return true;
            }
            return false;
          };
          Map3.prototype.clear = function() {
            this._keys.length = 0;
            this._values.length = 0;
            this._cacheKey = cacheSentinel;
            this._cacheIndex = -2;
          };
          Map3.prototype.keys = function() {
            return new MapIterator(this._keys, this._values, getKey);
          };
          Map3.prototype.values = function() {
            return new MapIterator(this._keys, this._values, getValue);
          };
          Map3.prototype.entries = function() {
            return new MapIterator(this._keys, this._values, getEntry);
          };
          Map3.prototype["@@iterator"] = function() {
            return this.entries();
          };
          Map3.prototype[iteratorSymbol] = function() {
            return this.entries();
          };
          Map3.prototype._find = function(key, insert) {
            if (!SameValueZero(this._cacheKey, key)) {
              this._cacheIndex = -1;
              for (var i2 = 0; i2 < this._keys.length; i2++) {
                if (SameValueZero(this._keys[i2], key)) {
                  this._cacheIndex = i2;
                  break;
                }
              }
            }
            if (this._cacheIndex < 0 && insert) {
              this._cacheIndex = this._keys.length;
              this._keys.push(key);
              this._values.push(void 0);
            }
            return this._cacheIndex;
          };
          return Map3;
        }()
      );
      return Map2;
      function getKey(key, _3) {
        return key;
      }
      function getValue(_3, value) {
        return value;
      }
      function getEntry(key, value) {
        return [key, value];
      }
    }
    function CreateSetPolyfill() {
      var Set2 = (
        /** @class */
        function() {
          function Set3() {
            this._map = new _Map();
          }
          Object.defineProperty(Set3.prototype, "size", {
            get: function() {
              return this._map.size;
            },
            enumerable: true,
            configurable: true
          });
          Set3.prototype.has = function(value) {
            return this._map.has(value);
          };
          Set3.prototype.add = function(value) {
            return this._map.set(value, value), this;
          };
          Set3.prototype.delete = function(value) {
            return this._map.delete(value);
          };
          Set3.prototype.clear = function() {
            this._map.clear();
          };
          Set3.prototype.keys = function() {
            return this._map.keys();
          };
          Set3.prototype.values = function() {
            return this._map.keys();
          };
          Set3.prototype.entries = function() {
            return this._map.entries();
          };
          Set3.prototype["@@iterator"] = function() {
            return this.keys();
          };
          Set3.prototype[iteratorSymbol] = function() {
            return this.keys();
          };
          return Set3;
        }()
      );
      return Set2;
    }
    function CreateWeakMapPolyfill() {
      var UUID_SIZE = 16;
      var keys = HashMap.create();
      var rootKey = CreateUniqueKey();
      return (
        /** @class */
        function() {
          function WeakMap2() {
            this._key = CreateUniqueKey();
          }
          WeakMap2.prototype.has = function(target) {
            var table = GetOrCreateWeakMapTable(
              target,
              /*create*/
              false
            );
            return table !== void 0 ? HashMap.has(table, this._key) : false;
          };
          WeakMap2.prototype.get = function(target) {
            var table = GetOrCreateWeakMapTable(
              target,
              /*create*/
              false
            );
            return table !== void 0 ? HashMap.get(table, this._key) : void 0;
          };
          WeakMap2.prototype.set = function(target, value) {
            var table = GetOrCreateWeakMapTable(
              target,
              /*create*/
              true
            );
            table[this._key] = value;
            return this;
          };
          WeakMap2.prototype.delete = function(target) {
            var table = GetOrCreateWeakMapTable(
              target,
              /*create*/
              false
            );
            return table !== void 0 ? delete table[this._key] : false;
          };
          WeakMap2.prototype.clear = function() {
            this._key = CreateUniqueKey();
          };
          return WeakMap2;
        }()
      );
      function CreateUniqueKey() {
        var key;
        do
          key = "@@WeakMap@@" + CreateUUID();
        while (HashMap.has(keys, key));
        keys[key] = true;
        return key;
      }
      function GetOrCreateWeakMapTable(target, create) {
        if (!hasOwn.call(target, rootKey)) {
          if (!create)
            return void 0;
          Object.defineProperty(target, rootKey, { value: HashMap.create() });
        }
        return target[rootKey];
      }
      function FillRandomBytes(buffer, size) {
        for (var i2 = 0; i2 < size; ++i2)
          buffer[i2] = Math.random() * 255 | 0;
        return buffer;
      }
      function GenRandomBytes(size) {
        if (typeof Uint8Array === "function") {
          var array = new Uint8Array(size);
          if (typeof crypto !== "undefined") {
            crypto.getRandomValues(array);
          } else if (typeof msCrypto !== "undefined") {
            msCrypto.getRandomValues(array);
          } else {
            FillRandomBytes(array, size);
          }
          return array;
        }
        return FillRandomBytes(new Array(size), size);
      }
      function CreateUUID() {
        var data = GenRandomBytes(UUID_SIZE);
        data[6] = data[6] & 79 | 64;
        data[8] = data[8] & 191 | 128;
        var result = "";
        for (var offset = 0; offset < UUID_SIZE; ++offset) {
          var byte = data[offset];
          if (offset === 4 || offset === 6 || offset === 8)
            result += "-";
          if (byte < 16)
            result += "0";
          result += byte.toString(16).toLowerCase();
        }
        return result;
      }
    }
    function MakeDictionary(obj) {
      obj.__ = void 0;
      delete obj.__;
      return obj;
    }
  });
})(Reflect2 || (Reflect2 = {}));

// node_modules/@inversifyjs/common/lib/esm/index.js
var t = Symbol.for("@inversifyjs/common/islazyServiceIdentifier");
var _a, _e;
_a = t;
var r = class {
  constructor(e2) {
    __publicField(this, _a);
    __privateAdd(this, _e);
    __privateSet(this, _e, e2), this[t] = true;
  }
  static is(e2) {
    return "object" == typeof e2 && null !== e2 && true === e2[t];
  }
  unwrap() {
    return __privateGet(this, _e).call(this);
  }
};
_e = new WeakMap();

// node_modules/@inversifyjs/reflect-metadata-utils/lib/esm/index.js
function t2(t3, e2) {
  return Reflect.getMetadata(e2, t3);
}
function e(e2, n, a3, c3) {
  const f3 = c3(t2(e2, n) ?? a3);
  Reflect.defineMetadata(n, f3, e2);
}

// node_modules/@inversifyjs/core/lib/esm/index.js
var a = "named";
var r2 = "name";
var i = "unmanaged";
var o = "optional";
var s = "inject";
var c = "multi_inject";
var u = "post_construct";
var d = "pre_destroy";
var m = [s, c, r2, i, a, o];
var l = Symbol.for("@inversifyjs/core/InversifyCoreError");
var _a2, _b;
var f = class _f extends (_b = Error, _a2 = l, _b) {
  constructor(t3, e2, n) {
    super(e2, n);
    __publicField(this, _a2);
    __publicField(this, "kind");
    this[l] = true, this.kind = t3;
  }
  static is(t3) {
    return "object" == typeof t3 && null !== t3 && true === t3[l];
  }
  static isErrorOfKind(t3, e2) {
    return _f.is(t3) && t3.kind === e2;
  }
};
var g;
var p;
function h(t3, e2) {
  const n = [];
  for (let t4 = 0; t4 < e2.length; ++t4) {
    void 0 === e2[t4] && n.push(t4);
  }
  if (n.length > 0) throw new f(g.missingInjectionDecorator, `Found unexpected missing metadata on type "${t3.name}" at constructor indexes "${n.join('", "')}".

Are you using @inject, @multiInject or @unmanaged decorators at those indexes?

If you're using typescript and want to rely on auto injection, set "emitDecoratorMetadata" compiler option to true`);
}
function y(t3) {
  return { kind: p.singleInjection, name: void 0, optional: false, tags: /* @__PURE__ */ new Map(), targetName: void 0, value: t3 };
}
function v(t3) {
  const e2 = t3.find((t4) => t4.key === s), n = t3.find((t4) => t4.key === c);
  if (void 0 !== t3.find((t4) => t4.key === i)) return function(t4, e3) {
    if (void 0 !== e3 || void 0 !== t4) throw new f(g.missingInjectionDecorator, "Expected a single @inject, @multiInject or @unmanaged metadata");
    return { kind: p.unmanaged };
  }(e2, n);
  if (void 0 === n && void 0 === e2) throw new f(g.missingInjectionDecorator, "Expected @inject, @multiInject or @unmanaged metadata");
  const u3 = t3.find((t4) => t4.key === a), d3 = t3.find((t4) => t4.key === o), l3 = t3.find((t4) => t4.key === r2);
  return { kind: void 0 === e2 ? p.multipleInjection : p.singleInjection, name: u3 == null ? void 0 : u3.value, optional: void 0 !== d3, tags: new Map(t3.filter((t4) => m.every((e3) => t4.key !== e3)).map((t4) => [t4.key, t4.value])), targetName: l3 == null ? void 0 : l3.value, value: void 0 === e2 ? n == null ? void 0 : n.value : e2.value };
}
function j(t3, e2, n) {
  try {
    return v(n);
  } catch (n2) {
    throw f.isErrorOfKind(n2, g.missingInjectionDecorator) ? new f(g.missingInjectionDecorator, `Expected a single @inject, @multiInject or @unmanaged decorator at type "${t3.name}" at constructor arguments at index "${e2.toString()}"`, { cause: n2 }) : n2;
  }
}
function k(e2) {
  const n = t2(e2, "design:paramtypes"), a3 = t2(e2, "inversify:tagged"), r3 = [];
  if (void 0 !== a3) for (const [t3, n2] of Object.entries(a3)) {
    const a4 = parseInt(t3);
    r3[a4] = j(e2, a4, n2);
  }
  if (void 0 !== n) {
    for (let t3 = 0; t3 < n.length; ++t3) if (void 0 === r3[t3]) {
      const e3 = n[t3];
      r3[t3] = y(e3);
    }
  }
  return h(e2, r3), r3;
}
function I(t3, e2, n) {
  try {
    return v(n);
  } catch (n2) {
    throw f.isErrorOfKind(n2, g.missingInjectionDecorator) ? new f(g.missingInjectionDecorator, `Expected a single @inject, @multiInject or @unmanaged decorator at type "${t3.name}" at property "${e2.toString()}"`, { cause: n2 }) : n2;
  }
}
function w(e2) {
  const n = t2(e2, "inversify:tagged_props"), a3 = /* @__PURE__ */ new Map();
  if (void 0 !== n) for (const t3 of Reflect.ownKeys(n)) {
    const r3 = n[t3];
    a3.set(t3, I(e2, t3, r3));
  }
  return a3;
}
function M(e2) {
  const n = t2(e2, u), a3 = t2(e2, d);
  return { constructorArguments: k(e2), lifecycle: { postConstructMethodName: n == null ? void 0 : n.value, preDestroyMethodName: a3 == null ? void 0 : a3.value }, properties: w(e2) };
}
function N(t3, e2) {
  const n = e2.getConstructorMetadata(t3), a3 = [];
  for (const [e3, r3] of Object.entries(n.userGeneratedMetadata)) {
    const n2 = parseInt(e3);
    a3[n2] = j(t3, n2, r3);
  }
  if (void 0 !== n.compilerGeneratedMetadata) {
    for (let t4 = 0; t4 < n.compilerGeneratedMetadata.length; ++t4) if (void 0 === a3[t4]) {
      const e3 = n.compilerGeneratedMetadata[t4];
      a3[t4] = y(e3);
    }
  }
  return h(t3, a3), a3;
}
function E(t3, e2) {
  const n = e2.getPropertiesMetadata(t3), a3 = /* @__PURE__ */ new Map();
  for (const e3 of Reflect.ownKeys(n)) {
    const r3 = n[e3];
    a3.set(e3, I(t3, e3, r3));
  }
  return a3;
}
function D(e2, n) {
  const a3 = t2(e2, u), r3 = t2(e2, d);
  return { constructorArguments: N(e2, n), lifecycle: { postConstructMethodName: a3 == null ? void 0 : a3.value, preDestroyMethodName: r3 == null ? void 0 : r3.value }, properties: E(e2, n) };
}
function b(t3) {
  const e2 = Object.getPrototypeOf(t3.prototype), n = e2 == null ? void 0 : e2.constructor;
  return n;
}
function O(t3) {
  return t3.kind === p.unmanaged ? [{ key: i, value: true }] : function(t4) {
    const e2 = [A(t4)];
    void 0 !== t4.name && e2.push({ key: a, value: t4.name });
    t4.optional && e2.push({ key: o, value: true });
    for (const [n, a3] of t4.tags) e2.push({ key: n, value: a3 });
    void 0 !== t4.targetName && e2.push({ key: r2, value: t4.targetName });
    return e2;
  }(t3);
}
function A(t3) {
  let e2;
  switch (t3.kind) {
    case p.multipleInjection:
      e2 = { key: c, value: t3.value };
      break;
    case p.singleInjection:
      e2 = { key: s, value: t3.value };
  }
  return e2;
}
!function(t3) {
  t3[t3.injectionDecoratorConflict = 0] = "injectionDecoratorConflict", t3[t3.missingInjectionDecorator = 1] = "missingInjectionDecorator", t3[t3.planning = 2] = "planning", t3[t3.unknown = 3] = "unknown";
}(g || (g = {})), function(t3) {
  t3[t3.multipleInjection = 0] = "multipleInjection", t3[t3.singleInjection = 1] = "singleInjection", t3[t3.unmanaged = 2] = "unmanaged";
}(p || (p = {}));
var _t;
var x = class {
  constructor(t3) {
    __privateAdd(this, _t);
    __privateSet(this, _t, t3);
  }
  startsWith(t3) {
    return __privateGet(this, _t).startsWith(t3);
  }
  endsWith(t3) {
    return __privateGet(this, _t).endsWith(t3);
  }
  contains(t3) {
    return __privateGet(this, _t).includes(t3);
  }
  equals(t3) {
    return __privateGet(this, _t) === t3;
  }
  value() {
    return __privateGet(this, _t);
  }
};
_t = new WeakMap();
var C = "@inversifyjs/core/targetId";
var _e2, _n, _a3, _r, _i, _o;
var T = class {
  constructor(n, a3, r3) {
    __privateAdd(this, _e2);
    __privateAdd(this, _n);
    __privateAdd(this, _a3);
    __privateAdd(this, _r);
    __privateAdd(this, _i);
    __privateAdd(this, _o);
    __privateSet(this, _n, function() {
      const n2 = t2(Object, C) ?? 0;
      return n2 === Number.MAX_SAFE_INTEGER ? e(Object, C, n2, () => Number.MIN_SAFE_INTEGER) : e(Object, C, n2, (t3) => t3 + 1), n2;
    }()), __privateSet(this, _a3, n), __privateSet(this, _r, void 0), __privateSet(this, _e2, a3), __privateSet(this, _i, new x("string" == typeof n ? n : n.toString().slice(7, -1))), __privateSet(this, _o, r3);
  }
  get id() {
    return __privateGet(this, _n);
  }
  get identifier() {
    return __privateGet(this, _a3);
  }
  get metadata() {
    return void 0 === __privateGet(this, _r) && __privateSet(this, _r, O(__privateGet(this, _e2))), __privateGet(this, _r);
  }
  get name() {
    return __privateGet(this, _i);
  }
  get type() {
    return __privateGet(this, _o);
  }
  get serviceIdentifier() {
    return r.is(__privateGet(this, _e2).value) ? __privateGet(this, _e2).value.unwrap() : __privateGet(this, _e2).value;
  }
  getCustomTags() {
    return [...__privateGet(this, _e2).tags.entries()].map(([t3, e2]) => ({ key: t3, value: e2 }));
  }
  getNamedTag() {
    return void 0 === __privateGet(this, _e2).name ? null : { key: a, value: __privateGet(this, _e2).name };
  }
  hasTag(t3) {
    return this.metadata.some((e2) => e2.key === t3);
  }
  isArray() {
    return __privateGet(this, _e2).kind === p.multipleInjection;
  }
  isNamed() {
    return void 0 !== __privateGet(this, _e2).name;
  }
  isOptional() {
    return __privateGet(this, _e2).optional;
  }
  isTagged() {
    return __privateGet(this, _e2).tags.size > 0;
  }
  matchesArray(t3) {
    return this.isArray() && __privateGet(this, _e2).value === t3;
  }
  matchesNamedTag(t3) {
    return __privateGet(this, _e2).name === t3;
  }
  matchesTag(t3) {
    return (e2) => this.metadata.some((n) => n.key === t3 && n.value === e2);
  }
};
_e2 = new WeakMap();
_n = new WeakMap();
_a3 = new WeakMap();
_r = new WeakMap();
_i = new WeakMap();
_o = new WeakMap();
var _ = (t3) => /* @__PURE__ */ function(t4, e2) {
  return function(n) {
    const a3 = t4(n);
    let r3 = b(n);
    for (; void 0 !== r3 && r3 !== Object; ) {
      const t5 = e2(r3);
      for (const [e3, n2] of t5) a3.properties.has(e3) || a3.properties.set(e3, n2);
      r3 = b(r3);
    }
    const i2 = [];
    for (const t5 of a3.constructorArguments) if (t5.kind !== p.unmanaged) {
      const e3 = t5.targetName ?? "";
      i2.push(new T(e3, t5, "ConstructorArgument"));
    }
    for (const [t5, e3] of a3.properties) if (e3.kind !== p.unmanaged) {
      const n2 = e3.targetName ?? t5;
      i2.push(new T(n2, e3, "ClassProperty"));
    }
    return i2;
  };
}(void 0 === t3 ? M : (e2) => D(e2, t3), void 0 === t3 ? w : (e2) => E(e2, t3));

// node_modules/inversify/lib/esm/index.js
var s2 = "named";
var o2 = "name";
var a2 = "unmanaged";
var c2 = "optional";
var d2 = "inject";
var u2 = "multi_inject";
var h2 = "inversify:tagged";
var l2 = "inversify:tagged_props";
var g2 = "inversify:paramtypes";
var y2 = "design:paramtypes";
var p2 = "post_construct";
var f2 = "pre_destroy";
var _2 = [d2, u2, o2, a2, s2, c2];
var v2 = Object.freeze({ __proto__: null, DESIGN_PARAM_TYPES: y2, INJECT_TAG: d2, MULTI_INJECT_TAG: u2, NAMED_TAG: s2, NAME_TAG: o2, NON_CUSTOM_TAG_KEYS: _2, OPTIONAL_TAG: c2, PARAM_TYPES: g2, POST_CONSTRUCT: p2, PRE_DESTROY: f2, TAGGED: h2, TAGGED_PROP: l2, UNMANAGED_TAG: a2 });
var b2 = { Request: "Request", Singleton: "Singleton", Transient: "Transient" };
var w2 = { ConstantValue: "ConstantValue", Constructor: "Constructor", DynamicValue: "DynamicValue", Factory: "Factory", Function: "Function", Instance: "Instance", Invalid: "Invalid", Provider: "Provider" };
var m2 = { ClassProperty: "ClassProperty", ConstructorArgument: "ConstructorArgument", Variable: "Variable" };
var A2 = 0;
function S() {
  return A2++;
}
var I2 = class _I {
  constructor(t3, n) {
    __publicField(this, "id");
    __publicField(this, "moduleId");
    __publicField(this, "activated");
    __publicField(this, "serviceIdentifier");
    __publicField(this, "implementationType");
    __publicField(this, "cache");
    __publicField(this, "dynamicValue");
    __publicField(this, "scope");
    __publicField(this, "type");
    __publicField(this, "factory");
    __publicField(this, "provider");
    __publicField(this, "constraint");
    __publicField(this, "onActivation");
    __publicField(this, "onDeactivation");
    this.id = S(), this.activated = false, this.serviceIdentifier = t3, this.scope = n, this.type = w2.Invalid, this.constraint = (t4) => true, this.implementationType = null, this.cache = null, this.factory = null, this.provider = null, this.onActivation = null, this.onDeactivation = null, this.dynamicValue = null;
  }
  clone() {
    const t3 = new _I(this.serviceIdentifier, this.scope);
    return t3.activated = t3.scope === b2.Singleton && this.activated, t3.implementationType = this.implementationType, t3.dynamicValue = this.dynamicValue, t3.scope = this.scope, t3.type = this.type, t3.factory = this.factory, t3.provider = this.provider, t3.constraint = this.constraint, t3.onActivation = this.onActivation, t3.onDeactivation = this.onDeactivation, t3.cache = this.cache, t3;
  }
};
var T2 = "Metadata key was used more than once in a parameter:";
var D2 = "NULL argument";
var N2 = "Key Not Found";
var C2 = "Ambiguous match found for serviceIdentifier:";
var x2 = "No matching bindings found for serviceIdentifier:";
var R = "The @inject @multiInject @tagged and @named decorators must be applied to the parameters of a class constructor or a class property.";
var E2 = (t3, n) => `onDeactivation() error in class ${t3}: ${n}`;
var M2 = class {
  getConstructorMetadata(t3) {
    return { compilerGeneratedMetadata: Reflect.getMetadata(y2, t3) ?? [], userGeneratedMetadata: Reflect.getMetadata(h2, t3) ?? {} };
  }
  getPropertiesMetadata(t3) {
    return Reflect.getMetadata(l2, t3) ?? {};
  }
};
var B;
function P(t3) {
  return t3 instanceof RangeError || "Maximum call stack size exceeded" === t3.message;
}
!function(t3) {
  t3[t3.MultipleBindingsAvailable = 2] = "MultipleBindingsAvailable", t3[t3.NoBindingsAvailable = 0] = "NoBindingsAvailable", t3[t3.OnlyOneBindingAvailable = 1] = "OnlyOneBindingAvailable";
}(B || (B = {}));
function k2(t3) {
  return "function" == typeof t3 ? t3.name : "symbol" == typeof t3 ? t3.toString() : t3;
}
function q(t3, n, e2) {
  let i2 = "";
  const r3 = e2(t3, n);
  return 0 !== r3.length && (i2 = "\nRegistered bindings:", r3.forEach((t4) => {
    let n2 = "Object";
    null !== t4.implementationType && (n2 = O2(t4.implementationType)), i2 = `${i2}
 ${n2}`, t4.constraint.metaData && (i2 = `${i2} - ${t4.constraint.metaData}`);
  })), i2;
}
function F(t3, n) {
  return null !== t3.parentRequest && (t3.parentRequest.serviceIdentifier === n || F(t3.parentRequest, n));
}
function j2(t3) {
  t3.childRequests.forEach((n) => {
    if (F(t3, n.serviceIdentifier)) {
      const t4 = function(t5) {
        const n2 = function t6(n3, e2 = []) {
          const i2 = k2(n3.serviceIdentifier);
          return e2.push(i2), null !== n3.parentRequest ? t6(n3.parentRequest, e2) : e2;
        }(t5);
        return n2.reverse().join(" --> ");
      }(n);
      throw new Error(`Circular dependency found: ${t4}`);
    }
    j2(n);
  });
}
function O2(t3) {
  if (null != t3.name && "" !== t3.name) return t3.name;
  {
    const n = t3.toString(), e2 = n.match(/^function\s*([^\s(]+)/);
    return null === e2 ? `Anonymous function: ${n}` : e2[1];
  }
}
function $(t3) {
  return `{"key":"${t3.key.toString()}","value":"${t3.value.toString()}"}`;
}
var V = class {
  constructor(t3) {
    __publicField(this, "id");
    __publicField(this, "container");
    __publicField(this, "plan");
    __publicField(this, "currentRequest");
    this.id = S(), this.container = t3;
  }
  addPlan(t3) {
    this.plan = t3;
  }
  setCurrentRequest(t3) {
    this.currentRequest = t3;
  }
};
var W = class {
  constructor(t3, n) {
    __publicField(this, "key");
    __publicField(this, "value");
    this.key = t3, this.value = n;
  }
  toString() {
    return this.key === s2 ? `named: ${String(this.value).toString()} ` : `tagged: { key:${this.key.toString()}, value: ${String(this.value)} }`;
  }
};
var G = class {
  constructor(t3, n) {
    __publicField(this, "parentContext");
    __publicField(this, "rootRequest");
    this.parentContext = t3, this.rootRequest = n;
  }
};
function K(t3, e2) {
  const i2 = function(t4) {
    const n = Object.getPrototypeOf(t4.prototype), e3 = n == null ? void 0 : n.constructor;
    return e3;
  }(e2);
  if (void 0 === i2 || i2 === Object) return 0;
  const r3 = _(t3)(i2), s3 = r3.map((t4) => t4.metadata.filter((t5) => t5.key === a2)), o3 = [].concat.apply([], s3).length, c3 = r3.length - o3;
  return c3 > 0 ? c3 : K(t3, i2);
}
var H = class _H {
  constructor(t3, n, e2, i2, r3) {
    __publicField(this, "id");
    __publicField(this, "serviceIdentifier");
    __publicField(this, "parentContext");
    __publicField(this, "parentRequest");
    __publicField(this, "bindings");
    __publicField(this, "childRequests");
    __publicField(this, "target");
    __publicField(this, "requestScope");
    this.id = S(), this.serviceIdentifier = t3, this.parentContext = n, this.parentRequest = e2, this.target = r3, this.childRequests = [], this.bindings = Array.isArray(i2) ? i2 : [i2], this.requestScope = null === e2 ? /* @__PURE__ */ new Map() : null;
  }
  addChildRequest(t3, n, e2) {
    const i2 = new _H(t3, this.parentContext, this, n, e2);
    return this.childRequests.push(i2), i2;
  }
};
function U(t3) {
  return t3._bindingDictionary;
}
function L(t3, n, e2, i2, r3) {
  let s3 = J(e2.container, r3.serviceIdentifier), o3 = [];
  return s3.length === B.NoBindingsAvailable && true === e2.container.options.autoBindInjectable && "function" == typeof r3.serviceIdentifier && t3.getConstructorMetadata(r3.serviceIdentifier).compilerGeneratedMetadata && (e2.container.bind(r3.serviceIdentifier).toSelf(), s3 = J(e2.container, r3.serviceIdentifier)), o3 = n ? s3 : s3.filter((t4) => {
    const n2 = new H(t4.serviceIdentifier, e2, i2, t4, r3);
    return t4.constraint(n2);
  }), function(t4, n2, e3, i3, r4) {
    switch (n2.length) {
      case B.NoBindingsAvailable:
        if (i3.isOptional()) return n2;
        {
          const n3 = k2(t4);
          let s4 = x2;
          throw s4 += function(t5, n4) {
            if (n4.isTagged() || n4.isNamed()) {
              let e4 = "";
              const i4 = n4.getNamedTag(), r5 = n4.getCustomTags();
              return null !== i4 && (e4 += $(i4) + "\n"), null !== r5 && r5.forEach((t6) => {
                e4 += $(t6) + "\n";
              }), ` ${t5}
 ${t5} - ${e4}`;
            }
            return ` ${t5}`;
          }(n3, i3), s4 += q(r4, n3, J), null !== e3 && (s4 += `
Trying to resolve bindings for "${k2(e3.serviceIdentifier)}"`), new Error(s4);
        }
      case B.OnlyOneBindingAvailable:
        return n2;
      case B.MultipleBindingsAvailable:
      default:
        if (i3.isArray()) return n2;
        {
          const n3 = k2(t4);
          let e4 = `${C2} ${n3}`;
          throw e4 += q(r4, n3, J), new Error(e4);
        }
    }
  }(r3.serviceIdentifier, o3, i2, r3, e2.container), o3;
}
function Y(t3, n) {
  const e2 = n.isMultiInject ? u2 : d2, i2 = [new W(e2, t3)];
  return void 0 !== n.customTag && i2.push(new W(n.customTag.key, n.customTag.value)), true === n.isOptional && i2.push(new W(c2, true)), i2;
}
function z(t3, e2, i2, r3, s3, o3) {
  let a3, c3;
  if (null === s3) {
    a3 = L(t3, e2, r3, null, o3), c3 = new H(i2, r3, null, a3, o3);
    const n = new G(r3, c3);
    r3.addPlan(n);
  } else a3 = L(t3, e2, r3, s3, o3), c3 = s3.addChildRequest(o3.serviceIdentifier, a3, o3);
  a3.forEach((e3) => {
    let i3 = null;
    if (o3.isArray()) i3 = c3.addChildRequest(e3.serviceIdentifier, e3, o3);
    else {
      if (null !== e3.cache) return;
      i3 = c3;
    }
    if (e3.type === w2.Instance && null !== e3.implementationType) {
      const s4 = function(t4, e4) {
        return _(t4)(e4);
      }(t3, e3.implementationType);
      if (true !== r3.container.options.skipBaseClassChecks) {
        const n = K(t3, e3.implementationType);
        if (s4.length < n) {
          const t4 = `The number of constructor arguments in the derived class ${O2(e3.implementationType)} must be >= than the number of constructor arguments of its base class.`;
          throw new Error(t4);
        }
      }
      s4.forEach((n) => {
        z(t3, false, n.serviceIdentifier, r3, i3, n);
      });
    }
  });
}
function J(t3, n) {
  let e2 = [];
  const i2 = U(t3);
  return i2.hasKey(n) ? e2 = i2.get(n) : null !== t3.parent && (e2 = J(t3.parent, n)), e2;
}
function Q(t3, n, s3, o3, a3, c3 = false) {
  const d3 = new V(n), u3 = function(t4, n2, s4) {
    const o4 = Y(n2, s4), a4 = v(o4);
    if (a4.kind === p.unmanaged) throw new Error("Unexpected metadata when creating target");
    return new T("", a4, t4);
  }(s3, o3, a3);
  try {
    return z(t3, c3, o3, d3, null, u3), d3;
  } catch (t4) {
    throw P(t4) && j2(d3.plan.rootRequest), t4;
  }
}
function X(t3) {
  return ("object" == typeof t3 && null !== t3 || "function" == typeof t3) && "function" == typeof t3.then;
}
function Z(t3) {
  return !!X(t3) || Array.isArray(t3) && t3.some(X);
}
var tt = (t3, n, e2) => {
  t3.has(n.id) || t3.set(n.id, e2);
};
var nt = (t3, n) => {
  t3.cache = n, t3.activated = true, X(n) && et(t3, n);
};
var et = async (t3, n) => {
  try {
    const e2 = await n;
    t3.cache = e2;
  } catch (n2) {
    throw t3.cache = null, t3.activated = false, n2;
  }
};
var it;
!function(t3) {
  t3.DynamicValue = "toDynamicValue", t3.Factory = "toFactory", t3.Provider = "toProvider";
}(it || (it = {}));
var rt = (t3) => (n) => (...e2) => {
  e2.forEach((e3) => {
    t3.bind(e3).toService(n);
  });
};
function st(t3, n, e2) {
  let i2;
  if (n.length > 0) {
    const r3 = function(t4, n2) {
      return t4.reduce((t5, e3) => {
        const i3 = n2(e3);
        return e3.target.type === m2.ConstructorArgument ? t5.constructorInjections.push(i3) : (t5.propertyRequests.push(e3), t5.propertyInjections.push(i3)), t5.isAsync || (t5.isAsync = Z(i3)), t5;
      }, { constructorInjections: [], isAsync: false, propertyInjections: [], propertyRequests: [] });
    }(n, e2), s3 = { ...r3, constr: t3 };
    i2 = r3.isAsync ? async function(t4) {
      const n2 = await at(t4.constructorInjections), e3 = await at(t4.propertyInjections);
      return ot({ ...t4, constructorInjections: n2, propertyInjections: e3 });
    }(s3) : ot(s3);
  } else i2 = new t3();
  return i2;
}
function ot(t3) {
  const n = new t3.constr(...t3.constructorInjections);
  return t3.propertyRequests.forEach((e2, i2) => {
    const r3 = e2.target.identifier, s3 = t3.propertyInjections[i2];
    e2.target.isOptional() && void 0 === s3 || (n[r3] = s3);
  }), n;
}
async function at(t3) {
  const n = [];
  for (const e2 of t3) Array.isArray(e2) ? n.push(Promise.all(e2)) : n.push(e2);
  return Promise.all(n);
}
function ct(t3, n) {
  const e2 = function(t4, n2) {
    var _a4;
    if (Reflect.hasMetadata(p2, t4)) {
      const r3 = Reflect.getMetadata(p2, t4);
      try {
        return (_a4 = n2[r3.value]) == null ? void 0 : _a4.call(n2);
      } catch (n3) {
        if (n3 instanceof Error) throw new Error((e3 = t4.name, i2 = n3.message, `@postConstruct error in class ${e3}: ${i2}`));
      }
    }
    var e3, i2;
  }(t3, n);
  return X(e2) ? e2.then(() => n) : n;
}
function dt(t3, n) {
  t3.scope !== b2.Singleton && function(t4, n2) {
    const e2 = `Class cannot be instantiated in ${t4.scope === b2.Request ? "request" : "transient"} scope.`;
    if ("function" == typeof t4.onDeactivation) throw new Error(E2(n2.name, e2));
    if (Reflect.hasMetadata(f2, n2)) throw new Error(`@preDestroy error in class ${n2.name}: ${e2}`);
  }(t3, n);
}
var ut = (t3) => (n) => {
  n.parentContext.setCurrentRequest(n);
  const e2 = n.bindings, i2 = n.childRequests, r3 = n.target && n.target.isArray(), s3 = !(n.parentRequest && n.parentRequest.target && n.target && n.parentRequest.target.matchesArray(n.target.serviceIdentifier));
  if (r3 && s3) return i2.map((n2) => ut(t3)(n2));
  {
    if (n.target.isOptional() && 0 === e2.length) return;
    const i3 = e2[0];
    return yt(t3, n, i3);
  }
};
var ht = (t3, n) => {
  const e2 = ((t4) => {
    switch (t4.type) {
      case w2.Factory:
        return { factory: t4.factory, factoryType: it.Factory };
      case w2.Provider:
        return { factory: t4.provider, factoryType: it.Provider };
      case w2.DynamicValue:
        return { factory: t4.dynamicValue, factoryType: it.DynamicValue };
      default:
        throw new Error(`Unexpected factory type ${t4.type}`);
    }
  })(t3);
  return ((t4, n2) => {
    try {
      return t4();
    } catch (t5) {
      if (P(t5)) throw n2();
      throw t5;
    }
  })(() => e2.factory.bind(t3)(n), () => {
    return new Error((t4 = e2.factoryType, i2 = n.currentRequest.serviceIdentifier.toString(), `It looks like there is a circular dependency in one of the '${t4}' bindings. Please investigate bindings with service identifier '${i2}'.`));
    var t4, i2;
  });
};
var lt = (t3, n, e2) => {
  let i2;
  const r3 = n.childRequests;
  switch (((t4) => {
    let n2 = null;
    switch (t4.type) {
      case w2.ConstantValue:
      case w2.Function:
        n2 = t4.cache;
        break;
      case w2.Constructor:
      case w2.Instance:
        n2 = t4.implementationType;
        break;
      case w2.DynamicValue:
        n2 = t4.dynamicValue;
        break;
      case w2.Provider:
        n2 = t4.provider;
        break;
      case w2.Factory:
        n2 = t4.factory;
    }
    if (null === n2) {
      const n3 = k2(t4.serviceIdentifier);
      throw new Error(`Invalid binding type: ${n3}`);
    }
  })(e2), e2.type) {
    case w2.ConstantValue:
    case w2.Function:
      i2 = e2.cache;
      break;
    case w2.Constructor:
      i2 = e2.implementationType;
      break;
    case w2.Instance:
      i2 = function(t4, n2, e3, i3) {
        dt(t4, n2);
        const r4 = st(n2, e3, i3);
        return X(r4) ? r4.then((t5) => ct(n2, t5)) : ct(n2, r4);
      }(e2, e2.implementationType, r3, ut(t3));
      break;
    default:
      i2 = ht(e2, n.parentContext);
  }
  return i2;
};
var gt = (t3, n, e2) => {
  let i2 = ((t4, n2) => n2.scope === b2.Singleton && n2.activated ? n2.cache : n2.scope === b2.Request && t4.has(n2.id) ? t4.get(n2.id) : null)(t3, n);
  return null !== i2 || (i2 = e2(), ((t4, n2, e3) => {
    n2.scope === b2.Singleton && nt(n2, e3), n2.scope === b2.Request && tt(t4, n2, e3);
  })(t3, n, i2)), i2;
};
var yt = (t3, n, e2) => gt(t3, e2, () => {
  let i2 = lt(t3, n, e2);
  return i2 = X(i2) ? i2.then((t4) => pt(n, e2, t4)) : pt(n, e2, i2), i2;
});
function pt(t3, n, e2) {
  let i2 = ft(t3.parentContext, n, e2);
  const r3 = wt(t3.parentContext.container);
  let s3, o3 = r3.next();
  do {
    s3 = o3.value;
    const n2 = t3.parentContext, e3 = t3.serviceIdentifier, a3 = bt(s3, e3);
    i2 = X(i2) ? vt(a3, n2, i2) : _t2(a3, n2, i2), o3 = r3.next();
  } while (true !== o3.done && !U(s3).hasKey(t3.serviceIdentifier));
  return i2;
}
var ft = (t3, n, e2) => {
  let i2;
  return i2 = "function" == typeof n.onActivation ? n.onActivation(t3, e2) : e2, i2;
};
var _t2 = (t3, n, e2) => {
  let i2 = t3.next();
  for (; true !== i2.done; ) {
    if (X(e2 = i2.value(n, e2))) return vt(t3, n, e2);
    i2 = t3.next();
  }
  return e2;
};
var vt = async (t3, n, e2) => {
  let i2 = await e2, r3 = t3.next();
  for (; true !== r3.done; ) i2 = await r3.value(n, i2), r3 = t3.next();
  return i2;
};
var bt = (t3, n) => {
  const e2 = t3._activations;
  return e2.hasKey(n) ? e2.get(n).values() : [].values();
};
var wt = (t3) => {
  const n = [t3];
  let e2 = t3.parent;
  for (; null !== e2; ) n.push(e2), e2 = e2.parent;
  return { next: () => {
    const t4 = n.pop();
    return void 0 !== t4 ? { done: false, value: t4 } : { done: true, value: void 0 };
  } };
};
var mt = (t3, n) => {
  const e2 = t3.parentRequest;
  return null !== e2 && (!!n(e2) || mt(e2, n));
};
var At = (t3) => (n) => {
  const e2 = (e3) => null !== e3 && null !== e3.target && e3.target.matchesTag(t3)(n);
  return e2.metaData = new W(t3, n), e2;
};
var St = At(s2);
var It = (t3) => (n) => {
  let e2 = null;
  if (null !== n) {
    if (e2 = n.bindings[0], "string" == typeof t3) return e2.serviceIdentifier === t3;
    {
      const e3 = n.bindings[0].implementationType;
      return t3 === e3;
    }
  }
  return false;
};
var Tt = class {
  constructor(t3) {
    __publicField(this, "_binding");
    this._binding = t3;
  }
  when(t3) {
    return this._binding.constraint = t3, new Dt(this._binding);
  }
  whenTargetNamed(t3) {
    return this._binding.constraint = St(t3), new Dt(this._binding);
  }
  whenTargetIsDefault() {
    return this._binding.constraint = (t3) => {
      if (null === t3) return false;
      return null !== t3.target && !t3.target.isNamed() && !t3.target.isTagged();
    }, new Dt(this._binding);
  }
  whenTargetTagged(t3, n) {
    return this._binding.constraint = At(t3)(n), new Dt(this._binding);
  }
  whenInjectedInto(t3) {
    return this._binding.constraint = (n) => null !== n && It(t3)(n.parentRequest), new Dt(this._binding);
  }
  whenParentNamed(t3) {
    return this._binding.constraint = (n) => null !== n && St(t3)(n.parentRequest), new Dt(this._binding);
  }
  whenParentTagged(t3, n) {
    return this._binding.constraint = (e2) => null !== e2 && At(t3)(n)(e2.parentRequest), new Dt(this._binding);
  }
  whenAnyAncestorIs(t3) {
    return this._binding.constraint = (n) => null !== n && mt(n, It(t3)), new Dt(this._binding);
  }
  whenNoAncestorIs(t3) {
    return this._binding.constraint = (n) => null !== n && !mt(n, It(t3)), new Dt(this._binding);
  }
  whenAnyAncestorNamed(t3) {
    return this._binding.constraint = (n) => null !== n && mt(n, St(t3)), new Dt(this._binding);
  }
  whenNoAncestorNamed(t3) {
    return this._binding.constraint = (n) => null !== n && !mt(n, St(t3)), new Dt(this._binding);
  }
  whenAnyAncestorTagged(t3, n) {
    return this._binding.constraint = (e2) => null !== e2 && mt(e2, At(t3)(n)), new Dt(this._binding);
  }
  whenNoAncestorTagged(t3, n) {
    return this._binding.constraint = (e2) => null !== e2 && !mt(e2, At(t3)(n)), new Dt(this._binding);
  }
  whenAnyAncestorMatches(t3) {
    return this._binding.constraint = (n) => null !== n && mt(n, t3), new Dt(this._binding);
  }
  whenNoAncestorMatches(t3) {
    return this._binding.constraint = (n) => null !== n && !mt(n, t3), new Dt(this._binding);
  }
};
var Dt = class {
  constructor(t3) {
    __publicField(this, "_binding");
    this._binding = t3;
  }
  onActivation(t3) {
    return this._binding.onActivation = t3, new Tt(this._binding);
  }
  onDeactivation(t3) {
    return this._binding.onDeactivation = t3, new Tt(this._binding);
  }
};
var Nt = class {
  constructor(t3) {
    __publicField(this, "_bindingWhenSyntax");
    __publicField(this, "_bindingOnSyntax");
    __publicField(this, "_binding");
    this._binding = t3, this._bindingWhenSyntax = new Tt(this._binding), this._bindingOnSyntax = new Dt(this._binding);
  }
  when(t3) {
    return this._bindingWhenSyntax.when(t3);
  }
  whenTargetNamed(t3) {
    return this._bindingWhenSyntax.whenTargetNamed(t3);
  }
  whenTargetIsDefault() {
    return this._bindingWhenSyntax.whenTargetIsDefault();
  }
  whenTargetTagged(t3, n) {
    return this._bindingWhenSyntax.whenTargetTagged(t3, n);
  }
  whenInjectedInto(t3) {
    return this._bindingWhenSyntax.whenInjectedInto(t3);
  }
  whenParentNamed(t3) {
    return this._bindingWhenSyntax.whenParentNamed(t3);
  }
  whenParentTagged(t3, n) {
    return this._bindingWhenSyntax.whenParentTagged(t3, n);
  }
  whenAnyAncestorIs(t3) {
    return this._bindingWhenSyntax.whenAnyAncestorIs(t3);
  }
  whenNoAncestorIs(t3) {
    return this._bindingWhenSyntax.whenNoAncestorIs(t3);
  }
  whenAnyAncestorNamed(t3) {
    return this._bindingWhenSyntax.whenAnyAncestorNamed(t3);
  }
  whenAnyAncestorTagged(t3, n) {
    return this._bindingWhenSyntax.whenAnyAncestorTagged(t3, n);
  }
  whenNoAncestorNamed(t3) {
    return this._bindingWhenSyntax.whenNoAncestorNamed(t3);
  }
  whenNoAncestorTagged(t3, n) {
    return this._bindingWhenSyntax.whenNoAncestorTagged(t3, n);
  }
  whenAnyAncestorMatches(t3) {
    return this._bindingWhenSyntax.whenAnyAncestorMatches(t3);
  }
  whenNoAncestorMatches(t3) {
    return this._bindingWhenSyntax.whenNoAncestorMatches(t3);
  }
  onActivation(t3) {
    return this._bindingOnSyntax.onActivation(t3);
  }
  onDeactivation(t3) {
    return this._bindingOnSyntax.onDeactivation(t3);
  }
};
var Ct = class {
  constructor(t3) {
    __publicField(this, "_binding");
    this._binding = t3;
  }
  inRequestScope() {
    return this._binding.scope = b2.Request, new Nt(this._binding);
  }
  inSingletonScope() {
    return this._binding.scope = b2.Singleton, new Nt(this._binding);
  }
  inTransientScope() {
    return this._binding.scope = b2.Transient, new Nt(this._binding);
  }
};
var xt = class {
  constructor(t3) {
    __publicField(this, "_bindingInSyntax");
    __publicField(this, "_bindingWhenSyntax");
    __publicField(this, "_bindingOnSyntax");
    __publicField(this, "_binding");
    this._binding = t3, this._bindingWhenSyntax = new Tt(this._binding), this._bindingOnSyntax = new Dt(this._binding), this._bindingInSyntax = new Ct(t3);
  }
  inRequestScope() {
    return this._bindingInSyntax.inRequestScope();
  }
  inSingletonScope() {
    return this._bindingInSyntax.inSingletonScope();
  }
  inTransientScope() {
    return this._bindingInSyntax.inTransientScope();
  }
  when(t3) {
    return this._bindingWhenSyntax.when(t3);
  }
  whenTargetNamed(t3) {
    return this._bindingWhenSyntax.whenTargetNamed(t3);
  }
  whenTargetIsDefault() {
    return this._bindingWhenSyntax.whenTargetIsDefault();
  }
  whenTargetTagged(t3, n) {
    return this._bindingWhenSyntax.whenTargetTagged(t3, n);
  }
  whenInjectedInto(t3) {
    return this._bindingWhenSyntax.whenInjectedInto(t3);
  }
  whenParentNamed(t3) {
    return this._bindingWhenSyntax.whenParentNamed(t3);
  }
  whenParentTagged(t3, n) {
    return this._bindingWhenSyntax.whenParentTagged(t3, n);
  }
  whenAnyAncestorIs(t3) {
    return this._bindingWhenSyntax.whenAnyAncestorIs(t3);
  }
  whenNoAncestorIs(t3) {
    return this._bindingWhenSyntax.whenNoAncestorIs(t3);
  }
  whenAnyAncestorNamed(t3) {
    return this._bindingWhenSyntax.whenAnyAncestorNamed(t3);
  }
  whenAnyAncestorTagged(t3, n) {
    return this._bindingWhenSyntax.whenAnyAncestorTagged(t3, n);
  }
  whenNoAncestorNamed(t3) {
    return this._bindingWhenSyntax.whenNoAncestorNamed(t3);
  }
  whenNoAncestorTagged(t3, n) {
    return this._bindingWhenSyntax.whenNoAncestorTagged(t3, n);
  }
  whenAnyAncestorMatches(t3) {
    return this._bindingWhenSyntax.whenAnyAncestorMatches(t3);
  }
  whenNoAncestorMatches(t3) {
    return this._bindingWhenSyntax.whenNoAncestorMatches(t3);
  }
  onActivation(t3) {
    return this._bindingOnSyntax.onActivation(t3);
  }
  onDeactivation(t3) {
    return this._bindingOnSyntax.onDeactivation(t3);
  }
};
var Rt = class {
  constructor(t3) {
    __publicField(this, "_binding");
    this._binding = t3;
  }
  to(t3) {
    return this._binding.type = w2.Instance, this._binding.implementationType = t3, new xt(this._binding);
  }
  toSelf() {
    if ("function" != typeof this._binding.serviceIdentifier) throw new Error("The toSelf function can only be applied when a constructor is used as service identifier");
    const t3 = this._binding.serviceIdentifier;
    return this.to(t3);
  }
  toConstantValue(t3) {
    return this._binding.type = w2.ConstantValue, this._binding.cache = t3, this._binding.dynamicValue = null, this._binding.implementationType = null, this._binding.scope = b2.Singleton, new Nt(this._binding);
  }
  toDynamicValue(t3) {
    return this._binding.type = w2.DynamicValue, this._binding.cache = null, this._binding.dynamicValue = t3, this._binding.implementationType = null, new xt(this._binding);
  }
  toConstructor(t3) {
    return this._binding.type = w2.Constructor, this._binding.implementationType = t3, this._binding.scope = b2.Singleton, new Nt(this._binding);
  }
  toFactory(t3) {
    return this._binding.type = w2.Factory, this._binding.factory = t3, this._binding.scope = b2.Singleton, new Nt(this._binding);
  }
  toFunction(t3) {
    if ("function" != typeof t3) throw new Error("Value provided to function binding must be a function!");
    const n = this.toConstantValue(t3);
    return this._binding.type = w2.Function, this._binding.scope = b2.Singleton, n;
  }
  toAutoFactory(t3) {
    return this._binding.type = w2.Factory, this._binding.factory = (n) => () => n.container.get(t3), this._binding.scope = b2.Singleton, new Nt(this._binding);
  }
  toAutoNamedFactory(t3) {
    return this._binding.type = w2.Factory, this._binding.factory = (n) => (e2) => n.container.getNamed(t3, e2), new Nt(this._binding);
  }
  toProvider(t3) {
    return this._binding.type = w2.Provider, this._binding.provider = t3, this._binding.scope = b2.Singleton, new Nt(this._binding);
  }
  toService(t3) {
    this._binding.type = w2.DynamicValue, Object.defineProperty(this._binding, "cache", { configurable: true, enumerable: true, get: () => null, set(t4) {
    } }), this._binding.dynamicValue = (n) => {
      try {
        return n.container.get(t3);
      } catch (e2) {
        return n.container.getAsync(t3);
      }
    }, this._binding.implementationType = null;
  }
};
var Et = class _Et {
  constructor() {
    __publicField(this, "bindings");
    __publicField(this, "activations");
    __publicField(this, "deactivations");
    __publicField(this, "middleware");
    __publicField(this, "moduleActivationStore");
  }
  static of(t3, n, e2, i2, r3) {
    const s3 = new _Et();
    return s3.bindings = t3, s3.middleware = n, s3.deactivations = i2, s3.activations = e2, s3.moduleActivationStore = r3, s3;
  }
};
var Mt = class _Mt {
  constructor() {
    __publicField(this, "_map");
    this._map = /* @__PURE__ */ new Map();
  }
  getMap() {
    return this._map;
  }
  add(t3, n) {
    if (this._checkNonNulish(t3), null == n) throw new Error(D2);
    const e2 = this._map.get(t3);
    void 0 !== e2 ? e2.push(n) : this._map.set(t3, [n]);
  }
  get(t3) {
    this._checkNonNulish(t3);
    const n = this._map.get(t3);
    if (void 0 !== n) return n;
    throw new Error(N2);
  }
  remove(t3) {
    if (this._checkNonNulish(t3), !this._map.delete(t3)) throw new Error(N2);
  }
  removeIntersection(t3) {
    this.traverse((n, e2) => {
      const i2 = t3.hasKey(n) ? t3.get(n) : void 0;
      if (void 0 !== i2) {
        const t4 = e2.filter((t5) => !i2.some((n2) => t5 === n2));
        this._setValue(n, t4);
      }
    });
  }
  removeByCondition(t3) {
    const n = [];
    return this._map.forEach((e2, i2) => {
      const r3 = [];
      for (const i3 of e2) {
        t3(i3) ? n.push(i3) : r3.push(i3);
      }
      this._setValue(i2, r3);
    }), n;
  }
  hasKey(t3) {
    return this._checkNonNulish(t3), this._map.has(t3);
  }
  clone() {
    const t3 = new _Mt();
    return this._map.forEach((n, e2) => {
      n.forEach((n2) => {
        var i2;
        t3.add(e2, "object" == typeof (i2 = n2) && null !== i2 && "clone" in i2 && "function" == typeof i2.clone ? n2.clone() : n2);
      });
    }), t3;
  }
  traverse(t3) {
    this._map.forEach((n, e2) => {
      t3(e2, n);
    });
  }
  _checkNonNulish(t3) {
    if (null == t3) throw new Error(D2);
  }
  _setValue(t3, n) {
    n.length > 0 ? this._map.set(t3, n) : this._map.delete(t3);
  }
};
var Bt = class _Bt {
  constructor() {
    __publicField(this, "_map", /* @__PURE__ */ new Map());
  }
  remove(t3) {
    const n = this._map.get(t3);
    return void 0 === n ? this._getEmptyHandlersStore() : (this._map.delete(t3), n);
  }
  addDeactivation(t3, n, e2) {
    this._getModuleActivationHandlers(t3).onDeactivations.add(n, e2);
  }
  addActivation(t3, n, e2) {
    this._getModuleActivationHandlers(t3).onActivations.add(n, e2);
  }
  clone() {
    const t3 = new _Bt();
    return this._map.forEach((n, e2) => {
      t3._map.set(e2, { onActivations: n.onActivations.clone(), onDeactivations: n.onDeactivations.clone() });
    }), t3;
  }
  _getModuleActivationHandlers(t3) {
    let n = this._map.get(t3);
    return void 0 === n && (n = this._getEmptyHandlersStore(), this._map.set(t3, n)), n;
  }
  _getEmptyHandlersStore() {
    return { onActivations: new Mt(), onDeactivations: new Mt() };
  }
};
var Pt = class _Pt {
  constructor(t3) {
    __publicField(this, "id");
    __publicField(this, "parent");
    __publicField(this, "options");
    __publicField(this, "_middleware");
    __publicField(this, "_bindingDictionary");
    __publicField(this, "_activations");
    __publicField(this, "_deactivations");
    __publicField(this, "_snapshots");
    __publicField(this, "_metadataReader");
    __publicField(this, "_moduleActivationStore");
    const n = t3 || {};
    if ("object" != typeof n) throw new Error("Invalid Container constructor argument. Container options must be an object.");
    if (void 0 === n.defaultScope) n.defaultScope = b2.Transient;
    else if (n.defaultScope !== b2.Singleton && n.defaultScope !== b2.Transient && n.defaultScope !== b2.Request) throw new Error('Invalid Container option. Default scope must be a string ("singleton" or "transient").');
    if (void 0 === n.autoBindInjectable) n.autoBindInjectable = false;
    else if ("boolean" != typeof n.autoBindInjectable) throw new Error("Invalid Container option. Auto bind injectable must be a boolean");
    if (void 0 === n.skipBaseClassChecks) n.skipBaseClassChecks = false;
    else if ("boolean" != typeof n.skipBaseClassChecks) throw new Error("Invalid Container option. Skip base check must be a boolean");
    this.options = { autoBindInjectable: n.autoBindInjectable, defaultScope: n.defaultScope, skipBaseClassChecks: n.skipBaseClassChecks }, this.id = S(), this._bindingDictionary = new Mt(), this._snapshots = [], this._middleware = null, this._activations = new Mt(), this._deactivations = new Mt(), this.parent = null, this._metadataReader = new M2(), this._moduleActivationStore = new Bt();
  }
  static merge(t3, n, ...e2) {
    const i2 = new _Pt(), r3 = [t3, n, ...e2].map((t4) => U(t4)), s3 = U(i2);
    return r3.forEach((t4) => {
      var n2;
      n2 = s3, t4.traverse((t5, e3) => {
        e3.forEach((t6) => {
          n2.add(t6.serviceIdentifier, t6.clone());
        });
      });
    }), i2;
  }
  load(...t3) {
    const n = this._getContainerModuleHelpersFactory();
    for (const e2 of t3) {
      const t4 = n(e2.id);
      e2.registry(t4.bindFunction, t4.unbindFunction, t4.isboundFunction, t4.rebindFunction, t4.unbindAsyncFunction, t4.onActivationFunction, t4.onDeactivationFunction);
    }
  }
  async loadAsync(...t3) {
    const n = this._getContainerModuleHelpersFactory();
    for (const e2 of t3) {
      const t4 = n(e2.id);
      await e2.registry(t4.bindFunction, t4.unbindFunction, t4.isboundFunction, t4.rebindFunction, t4.unbindAsyncFunction, t4.onActivationFunction, t4.onDeactivationFunction);
    }
  }
  unload(...t3) {
    t3.forEach((t4) => {
      const n = this._removeModuleBindings(t4.id);
      this._deactivateSingletons(n), this._removeModuleHandlers(t4.id);
    });
  }
  async unloadAsync(...t3) {
    for (const n of t3) {
      const t4 = this._removeModuleBindings(n.id);
      await this._deactivateSingletonsAsync(t4), this._removeModuleHandlers(n.id);
    }
  }
  bind(t3) {
    return this._bind(this._buildBinding(t3));
  }
  rebind(t3) {
    return this.unbind(t3), this.bind(t3);
  }
  async rebindAsync(t3) {
    return await this.unbindAsync(t3), this.bind(t3);
  }
  unbind(t3) {
    if (this._bindingDictionary.hasKey(t3)) {
      const n = this._bindingDictionary.get(t3);
      this._deactivateSingletons(n);
    }
    this._removeServiceFromDictionary(t3);
  }
  async unbindAsync(t3) {
    if (this._bindingDictionary.hasKey(t3)) {
      const n = this._bindingDictionary.get(t3);
      await this._deactivateSingletonsAsync(n);
    }
    this._removeServiceFromDictionary(t3);
  }
  unbindAll() {
    this._bindingDictionary.traverse((t3, n) => {
      this._deactivateSingletons(n);
    }), this._bindingDictionary = new Mt();
  }
  async unbindAllAsync() {
    const t3 = [];
    this._bindingDictionary.traverse((n, e2) => {
      t3.push(this._deactivateSingletonsAsync(e2));
    }), await Promise.all(t3), this._bindingDictionary = new Mt();
  }
  onActivation(t3, n) {
    this._activations.add(t3, n);
  }
  onDeactivation(t3, n) {
    this._deactivations.add(t3, n);
  }
  isBound(t3) {
    let n = this._bindingDictionary.hasKey(t3);
    return !n && this.parent && (n = this.parent.isBound(t3)), n;
  }
  isCurrentBound(t3) {
    return this._bindingDictionary.hasKey(t3);
  }
  isBoundNamed(t3, n) {
    return this.isBoundTagged(t3, s2, n);
  }
  isBoundTagged(t3, n, s3) {
    let o3 = false;
    if (this._bindingDictionary.hasKey(t3)) {
      const a3 = this._bindingDictionary.get(t3), c3 = function(t4, n2, s4) {
        const o4 = Y(n2, s4), a4 = v(o4);
        if (a4.kind === p.unmanaged) throw new Error("Unexpected metadata when creating target");
        const c4 = new T("", a4, "Variable"), d3 = new V(t4);
        return new H(n2, d3, null, [], c4);
      }(this, t3, { customTag: { key: n, value: s3 }, isMultiInject: false });
      o3 = a3.some((t4) => t4.constraint(c3));
    }
    return !o3 && this.parent && (o3 = this.parent.isBoundTagged(t3, n, s3)), o3;
  }
  snapshot() {
    this._snapshots.push(Et.of(this._bindingDictionary.clone(), this._middleware, this._activations.clone(), this._deactivations.clone(), this._moduleActivationStore.clone()));
  }
  restore() {
    const t3 = this._snapshots.pop();
    if (void 0 === t3) throw new Error("No snapshot available to restore.");
    this._bindingDictionary = t3.bindings, this._activations = t3.activations, this._deactivations = t3.deactivations, this._middleware = t3.middleware, this._moduleActivationStore = t3.moduleActivationStore;
  }
  createChild(t3) {
    const n = new _Pt(t3 || this.options);
    return n.parent = this, n;
  }
  applyMiddleware(...t3) {
    const n = this._middleware ? this._middleware : this._planAndResolve();
    this._middleware = t3.reduce((t4, n2) => n2(t4), n);
  }
  applyCustomMetadataReader(t3) {
    this._metadataReader = t3;
  }
  get(t3) {
    const n = this._getNotAllArgs(t3, false, false);
    return this._getButThrowIfAsync(n);
  }
  async getAsync(t3) {
    const n = this._getNotAllArgs(t3, false, false);
    return this._get(n);
  }
  getTagged(t3, n, e2) {
    const i2 = this._getNotAllArgs(t3, false, false, n, e2);
    return this._getButThrowIfAsync(i2);
  }
  async getTaggedAsync(t3, n, e2) {
    const i2 = this._getNotAllArgs(t3, false, false, n, e2);
    return this._get(i2);
  }
  getNamed(t3, n) {
    return this.getTagged(t3, s2, n);
  }
  async getNamedAsync(t3, n) {
    return this.getTaggedAsync(t3, s2, n);
  }
  getAll(t3, n) {
    const e2 = this._getAllArgs(t3, n, false);
    return this._getButThrowIfAsync(e2);
  }
  async getAllAsync(t3, n) {
    const e2 = this._getAllArgs(t3, n, false);
    return this._getAll(e2);
  }
  getAllTagged(t3, n, e2) {
    const i2 = this._getNotAllArgs(t3, true, false, n, e2);
    return this._getButThrowIfAsync(i2);
  }
  async getAllTaggedAsync(t3, n, e2) {
    const i2 = this._getNotAllArgs(t3, true, false, n, e2);
    return this._getAll(i2);
  }
  getAllNamed(t3, n) {
    return this.getAllTagged(t3, s2, n);
  }
  async getAllNamedAsync(t3, n) {
    return this.getAllTaggedAsync(t3, s2, n);
  }
  resolve(t3) {
    const n = this.isBound(t3);
    n || this.bind(t3).toSelf();
    const e2 = this.get(t3);
    return n || this.unbind(t3), e2;
  }
  tryGet(t3) {
    const n = this._getNotAllArgs(t3, false, true);
    return this._getButThrowIfAsync(n);
  }
  async tryGetAsync(t3) {
    const n = this._getNotAllArgs(t3, false, true);
    return this._get(n);
  }
  tryGetTagged(t3, n, e2) {
    const i2 = this._getNotAllArgs(t3, false, true, n, e2);
    return this._getButThrowIfAsync(i2);
  }
  async tryGetTaggedAsync(t3, n, e2) {
    const i2 = this._getNotAllArgs(t3, false, true, n, e2);
    return this._get(i2);
  }
  tryGetNamed(t3, n) {
    return this.tryGetTagged(t3, s2, n);
  }
  async tryGetNamedAsync(t3, n) {
    return this.tryGetTaggedAsync(t3, s2, n);
  }
  tryGetAll(t3, n) {
    const e2 = this._getAllArgs(t3, n, true);
    return this._getButThrowIfAsync(e2);
  }
  async tryGetAllAsync(t3, n) {
    const e2 = this._getAllArgs(t3, n, true);
    return this._getAll(e2);
  }
  tryGetAllTagged(t3, n, e2) {
    const i2 = this._getNotAllArgs(t3, true, true, n, e2);
    return this._getButThrowIfAsync(i2);
  }
  async tryGetAllTaggedAsync(t3, n, e2) {
    const i2 = this._getNotAllArgs(t3, true, true, n, e2);
    return this._getAll(i2);
  }
  tryGetAllNamed(t3, n) {
    return this.tryGetAllTagged(t3, s2, n);
  }
  async tryGetAllNamedAsync(t3, n) {
    return this.tryGetAllTaggedAsync(t3, s2, n);
  }
  _preDestroy(t3, n) {
    var _a4;
    if (void 0 !== t3 && Reflect.hasMetadata(f2, t3)) {
      const e2 = Reflect.getMetadata(f2, t3);
      return (_a4 = n[e2.value]) == null ? void 0 : _a4.call(n);
    }
  }
  _removeModuleHandlers(t3) {
    const n = this._moduleActivationStore.remove(t3);
    this._activations.removeIntersection(n.onActivations), this._deactivations.removeIntersection(n.onDeactivations);
  }
  _removeModuleBindings(t3) {
    return this._bindingDictionary.removeByCondition((n) => n.moduleId === t3);
  }
  _deactivate(t3, n) {
    const e2 = null == n ? void 0 : Object.getPrototypeOf(n).constructor;
    try {
      if (this._deactivations.hasKey(t3.serviceIdentifier)) {
        const i3 = this._deactivateContainer(n, this._deactivations.get(t3.serviceIdentifier).values());
        if (X(i3)) return this._handleDeactivationError(i3.then(async () => this._propagateContainerDeactivationThenBindingAndPreDestroyAsync(t3, n, e2)), t3.serviceIdentifier);
      }
      const i2 = this._propagateContainerDeactivationThenBindingAndPreDestroy(t3, n, e2);
      if (X(i2)) return this._handleDeactivationError(i2, t3.serviceIdentifier);
    } catch (n2) {
      if (n2 instanceof Error) throw new Error(E2(k2(t3.serviceIdentifier), n2.message));
    }
  }
  async _handleDeactivationError(t3, n) {
    try {
      await t3;
    } catch (t4) {
      if (t4 instanceof Error) throw new Error(E2(k2(n), t4.message));
    }
  }
  _deactivateContainer(t3, n) {
    let e2 = n.next();
    for (; "function" == typeof e2.value; ) {
      const i2 = e2.value(t3);
      if (X(i2)) return i2.then(async () => this._deactivateContainerAsync(t3, n));
      e2 = n.next();
    }
  }
  async _deactivateContainerAsync(t3, n) {
    let e2 = n.next();
    for (; "function" == typeof e2.value; ) await e2.value(t3), e2 = n.next();
  }
  _getContainerModuleHelpersFactory() {
    const t3 = (t4) => (n2) => {
      const e3 = this._buildBinding(n2);
      return e3.moduleId = t4, this._bind(e3);
    }, n = () => (t4) => {
      this.unbind(t4);
    }, e2 = () => async (t4) => this.unbindAsync(t4), i2 = () => (t4) => this.isBound(t4), r3 = (n2) => {
      const e3 = t3(n2);
      return (t4) => (this.unbind(t4), e3(t4));
    }, s3 = (t4) => (n2, e3) => {
      this._moduleActivationStore.addActivation(t4, n2, e3), this.onActivation(n2, e3);
    }, o3 = (t4) => (n2, e3) => {
      this._moduleActivationStore.addDeactivation(t4, n2, e3), this.onDeactivation(n2, e3);
    };
    return (a3) => ({ bindFunction: t3(a3), isboundFunction: i2(), onActivationFunction: s3(a3), onDeactivationFunction: o3(a3), rebindFunction: r3(a3), unbindAsyncFunction: e2(), unbindFunction: n() });
  }
  _bind(t3) {
    return this._bindingDictionary.add(t3.serviceIdentifier, t3), new Rt(t3);
  }
  _buildBinding(t3) {
    const n = this.options.defaultScope || b2.Transient;
    return new I2(t3, n);
  }
  async _getAll(t3) {
    return Promise.all(this._get(t3));
  }
  _get(t3) {
    const n = { ...t3, contextInterceptor: (t4) => t4, targetType: m2.Variable };
    if (this._middleware) {
      const t4 = this._middleware(n);
      if (null == t4) throw new Error("Invalid return type in middleware. Middleware must return!");
      return t4;
    }
    return this._planAndResolve()(n);
  }
  _getButThrowIfAsync(t3) {
    const n = this._get(t3);
    if (Z(n)) throw new Error(`You are attempting to construct ${function(t4) {
      return "function" == typeof t4 ? `[function/class ${t4.name || "<anonymous>"}]` : "symbol" == typeof t4 ? t4.toString() : `'${t4}'`;
    }(t3.serviceIdentifier)} in a synchronous way but it has asynchronous dependencies.`);
    return n;
  }
  _getAllArgs(t3, n, e2) {
    return { avoidConstraints: !(n == null ? void 0 : n.enforceBindingConstraints), isMultiInject: true, isOptional: e2, serviceIdentifier: t3 };
  }
  _getNotAllArgs(t3, n, e2, i2, r3) {
    return { avoidConstraints: false, isMultiInject: n, isOptional: e2, key: i2, serviceIdentifier: t3, value: r3 };
  }
  _getPlanMetadataFromNextArgs(t3) {
    const n = { isMultiInject: t3.isMultiInject };
    return void 0 !== t3.key && (n.customTag = { key: t3.key, value: t3.value }), true === t3.isOptional && (n.isOptional = true), n;
  }
  _planAndResolve() {
    return (t3) => {
      let n = Q(this._metadataReader, this, t3.targetType, t3.serviceIdentifier, this._getPlanMetadataFromNextArgs(t3), t3.avoidConstraints);
      n = t3.contextInterceptor(n);
      const e2 = function(t4) {
        return ut(t4.plan.rootRequest.requestScope)(t4.plan.rootRequest);
      }(n);
      return e2;
    };
  }
  _deactivateIfSingleton(t3) {
    if (t3.activated) return X(t3.cache) ? t3.cache.then((n) => this._deactivate(t3, n)) : this._deactivate(t3, t3.cache);
  }
  _deactivateSingletons(t3) {
    for (const n of t3) {
      if (X(this._deactivateIfSingleton(n))) throw new Error("Attempting to unbind dependency with asynchronous destruction (@preDestroy or onDeactivation)");
    }
  }
  async _deactivateSingletonsAsync(t3) {
    await Promise.all(t3.map(async (t4) => this._deactivateIfSingleton(t4)));
  }
  _propagateContainerDeactivationThenBindingAndPreDestroy(t3, n, e2) {
    return this.parent ? this._deactivate.bind(this.parent)(t3, n) : this._bindingDeactivationAndPreDestroy(t3, n, e2);
  }
  async _propagateContainerDeactivationThenBindingAndPreDestroyAsync(t3, n, e2) {
    this.parent ? await this._deactivate.bind(this.parent)(t3, n) : await this._bindingDeactivationAndPreDestroyAsync(t3, n, e2);
  }
  _removeServiceFromDictionary(t3) {
    try {
      this._bindingDictionary.remove(t3);
    } catch (n) {
      throw new Error(`Could not unbind serviceIdentifier: ${k2(t3)}`);
    }
  }
  _bindingDeactivationAndPreDestroy(t3, n, e2) {
    if ("function" == typeof t3.onDeactivation) {
      const i2 = t3.onDeactivation(n);
      if (X(i2)) return i2.then(() => this._preDestroy(e2, n));
    }
    return this._preDestroy(e2, n);
  }
  async _bindingDeactivationAndPreDestroyAsync(t3, n, e2) {
    "function" == typeof t3.onDeactivation && await t3.onDeactivation(n), await this._preDestroy(e2, n);
  }
};
var kt = class {
  constructor(t3) {
    __publicField(this, "id");
    __publicField(this, "registry");
    this.id = S(), this.registry = t3;
  }
};
var qt = class {
  constructor(t3) {
    __publicField(this, "id");
    __publicField(this, "registry");
    this.id = S(), this.registry = t3;
  }
};
function Ft(t3, n, e2, i2) {
  !function(t4) {
    if (void 0 !== t4) throw new Error(R);
  }(n), Ot(h2, t3, e2.toString(), i2);
}
function jt(t3) {
  let n = [];
  if (Array.isArray(t3)) {
    n = t3;
    const e2 = function(t4) {
      const n2 = /* @__PURE__ */ new Set();
      for (const e3 of t4) {
        if (n2.has(e3)) return e3;
        n2.add(e3);
      }
    }(n.map((t4) => t4.key));
    if (void 0 !== e2) throw new Error(`${T2} ${e2.toString()}`);
  } else n = [t3];
  return n;
}
function Ot(t3, n, e2, i2) {
  const r3 = jt(i2);
  let s3 = {};
  Reflect.hasOwnMetadata(t3, n) && (s3 = Reflect.getMetadata(t3, n));
  let o3 = s3[e2];
  if (void 0 === o3) o3 = [];
  else for (const t4 of o3) if (r3.some((n2) => n2.key === t4.key)) throw new Error(`${T2} ${t4.key.toString()}`);
  o3.push(...r3), s3[e2] = o3, Reflect.defineMetadata(t3, s3, n);
}
function $t(t3) {
  return (n, e2, i2) => {
    "number" == typeof i2 ? Ft(n, e2, i2, t3) : function(t4, n2, e3) {
      if (void 0 !== t4.prototype) throw new Error(R);
      Ot(l2, t4.constructor, n2, e3);
    }(n, e2, t3);
  };
}
function Vt(t3, n) {
  Reflect.decorate(t3, n);
}
function Wt(t3, n) {
  return function(e2, i2) {
    n(e2, i2, t3);
  };
}
function Gt(t3, n, e2) {
  "number" == typeof e2 ? Vt([Wt(e2, t3)], n) : "string" == typeof e2 ? Reflect.decorate([t3], n, e2) : Vt([t3], n);
}
function Kt() {
  return function(t3) {
    if (Reflect.hasOwnMetadata(g2, t3)) throw new Error("Cannot apply @injectable decorator multiple times.");
    const n = Reflect.getMetadata(y2, t3) || [];
    return Reflect.defineMetadata(g2, n, t3), t3;
  };
}
function Ht(t3, n) {
  return $t(new W(t3, n));
}
function Ut(t3) {
  return $t(new W(s2, t3));
}
function Lt(t3) {
  return (n) => (e2, i2, r3) => {
    if (void 0 === n) {
      const t4 = "function" == typeof e2 ? e2.name : e2.constructor.name;
      throw new Error(`@inject called with undefined this could mean that the class ${t4} has a circular dependency problem. You can use a LazyServiceIdentifer to overcome this limitation.`);
    }
    $t(new W(t3, n))(e2, i2, r3);
  };
}
var Yt = Lt(d2);
function zt() {
  return $t(new W(c2, true));
}
function Jt() {
  return function(t3, n, e2) {
    Ft(t3, n, e2, new W(a2, true));
  };
}
var Qt = Lt(u2);
function Xt(t3) {
  return function(n, e2, i2) {
    Ft(n, e2, i2, new W(o2, t3));
  };
}
function Zt(t3, n) {
  return () => (e2, i2) => {
    const r3 = new W(t3, i2);
    if (Reflect.hasOwnMetadata(t3, e2.constructor)) throw new Error(n);
    Reflect.defineMetadata(t3, r3, e2.constructor);
  };
}
var tn = Zt(p2, "Cannot apply @postConstruct decorator multiple times in the same class");
var nn = Zt(f2, "Cannot apply @preDestroy decorator multiple times in the same class");
var en = r;
var rn = v2;
export {
  qt as AsyncContainerModule,
  b2 as BindingScopeEnum,
  w2 as BindingTypeEnum,
  Pt as Container,
  kt as ContainerModule,
  en as LazyServiceIdentifer,
  r as LazyServiceIdentifier,
  rn as METADATA_KEY,
  M2 as MetadataReader,
  m2 as TargetTypeEnum,
  $t as createTaggedDecorator,
  Gt as decorate,
  k2 as getServiceIdentifierAsString,
  S as id,
  Yt as inject,
  Kt as injectable,
  rt as multiBindToService,
  Qt as multiInject,
  Ut as named,
  St as namedConstraint,
  zt as optional,
  tn as postConstruct,
  nn as preDestroy,
  Ht as tagged,
  At as taggedConstraint,
  Xt as targetName,
  mt as traverseAncerstors,
  It as typeConstraint,
  Jt as unmanaged
};
/*! Bundled license information:

reflect-metadata/Reflect.js:
  (*! *****************************************************************************
  Copyright (C) Microsoft. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0
  
  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.
  
  See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** *)
*/
//# sourceMappingURL=inversify.js.map
